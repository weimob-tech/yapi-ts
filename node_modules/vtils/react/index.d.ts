/**
 * React 工具库。基于 {@link https://github.com/streamich/react-use#readme | react-use}。
 *
 * @packageDocumentation
 */

import { DependencyList } from 'react';
import { Dispatch } from 'react';
import { MutableRefObject } from 'react';
import { default as React_2 } from 'react';
import { SetStateAction } from 'react';
import { useAsync } from 'react-use';
import { useAsyncFn } from 'react-use';
import { useAsyncRetry } from 'react-use';
import { useAudio } from 'react-use';
import { useBattery } from 'react-use';
import { useBeforeUnload } from 'react-use';
import { useBoolean } from 'react-use';
import { useClickAway } from 'react-use';
import { useCookie } from 'react-use';
import { useCopyToClipboard } from 'react-use';
import { useCounter } from 'react-use';
import { useCss } from 'react-use';
import { useCustomCompareEffect } from 'react-use';
import { useDebounce } from 'react-use';
import { useDeepCompareEffect } from 'react-use';
import { useDefault } from 'react-use';
import { useDrop } from 'react-use';
import { useDropArea } from 'react-use';
import { useEffectOnce } from 'react-use';
import { useEnsuredForwardedRef } from 'react-use';
import { useError } from 'react-use';
import { useEvent } from 'react-use';
import { useFavicon } from 'react-use';
import { useFirstMountState } from 'react-use';
import { useFullscreen } from 'react-use';
import { useGeolocation } from 'react-use';
import { useGetSet } from 'react-use';
import { useGetSetState } from 'react-use';
import { useHarmonicIntervalFn } from 'react-use';
import { useHash } from 'react-use';
import { useHoverDirty } from 'react-use';
import { useIdle } from 'react-use';
import { useIntersection } from 'react-use';
import { useIsomorphicLayoutEffect } from 'react-use';
import { useKey } from 'react-use';
import { useKeyPress } from 'react-use';
import { useKeyPressEvent } from 'react-use';
import { useLatest } from 'react-use';
import { useLifecycles } from 'react-use';
import { useList } from 'react-use';
import { useLocation } from 'react-use';
import { useLockBodyScroll } from 'react-use';
import { useLogger } from 'react-use';
import { useLongPress } from 'react-use';
import { useMap } from 'react-use';
import { useMeasure } from 'react-use';
import { useMedia } from 'react-use';
import { useMediaDevices } from 'react-use';
import { useMediatedState } from 'react-use';
import { useMethods } from 'react-use';
import { useMotion } from 'react-use';
import { useMount } from 'react-use';
import { useMountedState } from 'react-use';
import { useMouse } from 'react-use';
import { useMouseHovered } from 'react-use';
import { useMouseWheel } from 'react-use';
import { useMultiStateValidator } from 'react-use';
import { useNetworkState } from 'react-use';
import { useNumber } from 'react-use';
import { useObservable } from 'react-use';
import { useOrientation } from 'react-use';
import { usePageLeave } from 'react-use';
import { usePermission } from 'react-use';
import { usePrevious } from 'react-use';
import { usePreviousDistinct } from 'react-use';
import { usePromise } from 'react-use';
import { useQueue } from 'react-use';
import { useRaf } from 'react-use';
import { useRafLoop } from 'react-use';
import { useRafState } from 'react-use';
import { useRendersCount } from 'react-use';
import { useScratch } from 'react-use';
import { useScroll } from 'react-use';
import { useScrollbarWidth } from 'react-use';
import { useScrolling } from 'react-use';
import { useSearchParam } from 'react-use';
import { useSessionStorage } from 'react-use';
import { useSet } from 'react-use';
import { useSetState } from 'react-use';
import { useShallowCompareEffect } from 'react-use';
import { useSize } from 'react-use';
import { useSlider } from 'react-use';
import { useSpeech } from 'react-use';
import { useStartTyping } from 'react-use';
import { useStateList } from 'react-use';
import { useStateValidator } from 'react-use';
import { useStateWithHistory } from 'react-use';
import { useThrottle } from 'react-use';
import { useThrottleFn } from 'react-use';
import { useTimeout } from 'react-use';
import { useTimeoutFn } from 'react-use';
import { useTitle } from 'react-use';
import { useTween } from 'react-use';
import { useUnmount } from 'react-use';
import { useUnmountPromise } from 'react-use';
import { useUpdate } from 'react-use';
import { useUpdateEffect } from 'react-use';
import { useUpsert } from 'react-use';
import { useVibrate } from 'react-use';
import { useVideo } from 'react-use';
import { useWindowScroll } from 'react-use';
import { useWindowSize } from 'react-use';

declare function addMethod<TSchemaType extends typeof mixed | typeof string | typeof number | typeof boolean | typeof date | typeof array | typeof object, TSchema extends TSchemaType extends typeof mixed ? MixedSchema : TSchemaType extends typeof string ? StringSchema : TSchemaType extends typeof number ? NumberSchema : TSchemaType extends typeof boolean ? BooleanSchema : TSchemaType extends typeof date ? DateSchema : TSchemaType extends typeof array ? ArraySchema : TSchemaType extends typeof object ? ObjectSchema : MixedSchema>(schemaType: TSchemaType, name: string, fn: (this: TSchema, ...args: any[]) => TSchema): void;

/**
 * 任意对象。
 *
 * @public
 */
declare type AnyObject_2 = Record<any, any>;

declare function array<T extends any = any>(): ArraySchema<T>;

declare interface ArrayLocale {
    min: LocaleValue<{
        min: number;
    }>;
    max: LocaleValue<{
        max: number;
    }>;
}

declare interface ArraySchema<T extends any = any> extends MixedSchema<T[]> {
    of(type: GetSchema<T>): this;
    required(message?: MixedLocale['required']): this;
    min(limit: number | Ref, message?: ArrayLocale['min']): this;
    max(limit: number | Ref, message?: ArrayLocale['max']): this;
    ensure(): this;
    compact(rejector: (value: T) => boolean): this;
}

declare function boolean<T extends boolean = boolean>(): BooleanSchema<T>;

declare interface BooleanLocale {
}

declare interface BooleanSchema<T extends boolean = boolean> extends MixedSchema<T> {
}

declare type Builtin = Primitive | Function | Date | Error | RegExp;

/**
 * 常用的组件属性。
 */
export declare interface CommonComponentProps<TRef = never> {
    key?: React_2.Key;
    ref?: React_2.Ref<TRef>;
    className?: string;
    style?: React_2.CSSProperties;
}

export declare function createGlobalState<S extends CreateGlobalStateState, R = never>(initialState: S): CreateGlobalStateResult<S, R>;

export declare function createGlobalState<S extends CreateGlobalStateState, R = never>(customResult?: CreateGlobalStateCustomResult<S, R>): CreateGlobalStateResult<S | undefined, R>;

export declare function createGlobalState<S extends CreateGlobalStateState, R = never>(initialState: S, customResult?: CreateGlobalStateCustomResult<S, R>): CreateGlobalStateResult<S, R>;

export declare type CreateGlobalStateCustomResult<S extends CreateGlobalStateState | undefined, R = never> = (payload: {
    state: CreateGlobalStateResultResult<S, never>[0];
    setState: CreateGlobalStateResultResult<S, never>[1];
}) => R;

export declare interface CreateGlobalStateResult<S extends CreateGlobalStateState | undefined, R = never> {
    (): CreateGlobalStateResultResult<S, R>;
    getState(): S;
    setState(nextState: SetStateAction<S>): void;
    setStatePartial(nextState: Partial<S> | ((prevState: S) => Partial<S>)): void;
    watchState(callback: (nextState: S, prevState: S) => any): () => void;
    watchStateImmediate(callback: (nextState: S, prevState: S) => any): () => void;
}

export declare type CreateGlobalStateResultResult<S extends CreateGlobalStateState | undefined, R = never> = [R] extends [never] ? readonly [S, Dispatch<SetStateAction<S>>] : R;

export declare type CreateGlobalStateState = any;

declare function date<T extends Date = Date>(): DateSchema<T>;

declare interface DateLocale {
    min: LocaleValue<{
        min: Date | string;
    }>;
    max: LocaleValue<{
        max: Date | string;
    }>;
}

declare interface DateSchema<T extends Date = Date> extends MixedSchema<T> {
    min(limit: Date | Ref, message?: DateLocale['min']): this;
    max(limit: Date | Ref, message?: DateLocale['max']): this;
}

/** Like Partial but recursive */
declare type DeepPartial<T> = T extends Builtin
? T
: T extends Map<infer K, infer V>
? Map<DeepPartial<K>, DeepPartial<V>>
: T extends ReadonlyMap<infer K, infer V>
? ReadonlyMap<DeepPartial<K>, DeepPartial<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<DeepPartial<K>, DeepPartial<V>>
: T extends Set<infer U>
? Set<DeepPartial<U>>
: T extends ReadonlySet<infer U>
? ReadonlySet<DeepPartial<U>>
: T extends WeakSet<infer U>
? WeakSet<DeepPartial<U>>
: T extends Array<infer U>
? T extends IsTuple<T>
? {
    [K in keyof T]?: DeepPartial<T[K]>;
}
: Array<DeepPartial<U>>
: T extends Promise<infer U>
? Promise<DeepPartial<U>>
: T extends {}
? {
    [K in keyof T]?: DeepPartial<T[K]>;
}
: Partial<T>;

/**
 * 定义组件。
 *
 * @param options 选项
 */
export declare function defineComponent<TProps extends Record<string, any>, TRef extends any = any>(options: DefineComponentOptions<TProps, true, TRef>): React_2.ForwardRefExoticComponent<TProps & {
    ref?: React_2.Ref<TRef>;
}>;

/**
 * 定义组件。
 *
 * @param options 选项
 */
export declare function defineComponent<TProps extends Record<string, any>, TRef extends any = any>(options: DefineComponentOptions<TProps, false>): React_2.FC<TProps>;

/**
 * 定义组件的选项。
 */
export declare type DefineComponentOptions<
/**
* 组件属性。
*/
TProps extends Record<string, any>, 
/**
* 是否转发 ref。
*/
TForwardRef extends boolean, 
/**
* 要转发的 ref。
*/
TRef extends any = never> = {
    /**
     * 可选属性的默认值。
     */
    defaultProps?: {
        [K in OptionalKeys<TProps>]?: TProps[K];
    };
    /**
     * 组件展示名称。
     */
    displayName?: string;
    /**
     * 组件。
     */
    component: TForwardRef extends true ? React_2.ForwardRefRenderFunction<TRef, Omit<TProps, 'key' | 'ref'>> : React_2.FC<Omit<TProps, 'key' | 'ref'>>;
} & (TForwardRef extends true ? {
    /**
     * 是否转发 ref。
     */
    forwardRef?: true;
} : {
    /**
     * 是否转发 ref。
     */
    forwardRef: false;
});

/**
 * 去除类型 T 中的 undefined。
 *
 * @public
 * @example
 * ```typescript
 * type X = string | undefined
 * type Y = Defined<X> // => string
 * ```
 */
declare type Defined<T> = Exclude<T, undefined>;

/**
 * 派生新的组件属性。
 *
 * @template TComponent 原组件
 * @template TExclude 需去除的属性
 * @template TRef 新的 ref
 * @template TOverride 覆盖属性
 */
export declare type DeriveComponentProps<TComponent extends React_2.ComponentType | keyof JSX.IntrinsicElements | React_2.JSXElementConstructor<any>, TExclude extends keyof React_2.ComponentProps<TComponent>, TRef extends any = never, TOverride extends Partial<Record<keyof React_2.ComponentProps<TComponent>, any>> = never> = Merge<Merge<Omit<React_2.ComponentProps<TComponent>, TExclude>, [
TOverride
] extends [never] ? {} : TOverride>, {
    ref?: React_2.Ref<TRef>;
}>;

declare interface GetEnvironmentResult {
    /** 浏览器 */
    readonly browser: boolean;
    /** 微信 WebView */
    readonly wechatWebView: boolean;
    /** 小程序 */
    readonly miniProgram: boolean;
    /** 微信小程序 */
    readonly wechatMiniProgram: boolean;
    /** iOS */
    readonly ios: boolean;
    /** 安卓 */
    readonly android: boolean;
    /** Node.js */
    readonly nodejs: boolean;
    /** Deno */
    readonly deno: boolean;
    /** Taro 3 */
    readonly taro: boolean;
}

declare function getLocale(): Locale;

declare type GetObjectSchema<T extends {}> = {
    [K in keyof T]: GetSchema<T[K]>;
};

declare type GetSchema<T> = T extends string ? StringSchema<string> : T extends number ? NumberSchema<number> : T extends boolean ? BooleanSchema<boolean> : T extends Array<infer X> ? ArraySchema<X> : T extends {} ? ObjectSchema<T> : MixedSchema<T>;

declare type IsTuple<T> = T extends [infer A]
? T
: T extends [infer A, infer B]
? T
: T extends [infer A, infer B, infer C]
? T
: T extends [infer A, infer B, infer C, infer D]
? T
: T extends [infer A, infer B, infer C, infer D, infer E]
? T
: never;

/**
 * 是否是渲染后可见的值。
 * 渲染后不可见的值包括：`undefined`、`null`、`true`、`false`、空字符串。
 *
 * @param value 值
 * @returns 返回结果
 * ```typescript
 * isVisibleValue(null) // => false
 * isVisibleValue(0) // => true
 * ```
 */
export declare function isVisibleValue(value: any): boolean;

declare interface Lazy extends MixedSchema {
}

declare function lazy<X extends MixedSchema>(fn: (value: any) => X): Lazy;

declare interface Locale {
    mixed: MixedLocale;
    string: StringLocale;
    number: NumberLocale;
    date: DateLocale;
    boolean: BooleanLocale;
    object: ObjectLocale;
    array: ArrayLocale;
}

declare type LocaleValue<TExtra extends {} = {}> = string | LocaleValueFn<TExtra>;

declare type LocaleValueFn<TExtra extends {} = {}> = (params: LocaleValueFnParams<TExtra>) => string;

declare type LocaleValueFnParams<TExtra extends {} = {}> = {
    path: string;
    type: string;
    label?: string;
    value: any;
    originalValue: any;
} & TExtra;

/** Merge 2 types, properties types from the latter override the ones defined on the former type */
declare type Merge<M, N> = Omit<M, keyof N> & N;

declare function mixed<T = any>(): MixedSchema<T>;

declare interface MixedLocale {
    default: LocaleValue;
    required: LocaleValue;
    oneOf: LocaleValue<{
        values: string;
    }>;
    notOneOf: LocaleValue<{
        values: string;
    }>;
    notType: LocaleValue;
    defined: LocaleValue;
}

declare interface MixedSchema<T = any> {
    __isYupSchema__: true;
    type: 'mixed' | 'string' | 'number' | 'boolean' | 'object' | 'date' | 'array';
    clone(): this;
    label(label: string): this;
    meta(meta: {}): this;
    describe(): SchemaDescription;
    /** @类型不友好 */
    concat(schema: MixedSchema<any>): this;
    validate(value: T, options?: SchemaValidateOptions): Promise<T>;
    validateSync(value: T, options?: SchemaValidateOptions): T;
    /**
     * 验证增强，包括：对象顺序验证、返回结果包含错误信息。
     */
    validatePlus(value: T, options?: SchemaValidateOptions): Promise<{
        error?: ValidationError;
        data: T;
    }>;
    /**
     * 验证增强，包括：对象顺序验证、返回结果包含错误信息。
     */
    validatePlusSync(value: T, options?: SchemaValidateOptions): {
        error?: ValidationError;
        data: T;
    };
    /** @类型不友好 */
    validateAt(path: string, value: any, options?: SchemaValidateOptions): Promise<any>;
    /** @类型不友好 */
    validateSyncAt(path: string, value: any, options?: SchemaValidateOptions): any;
    isValid(value: T, options?: SchemaValidateOptions): Promise<boolean>;
    isValidSync(value: T, options?: SchemaValidateOptions): boolean;
    cast(value: T, options?: SchemaValidateOptions): any;
    isType(value: T): boolean;
    strict(isStrict?: boolean): this;
    strip(stripField?: boolean): this;
    withMutation<X>(fn: (schema: this) => X): X;
    default(value: T | (() => T)): this;
    default(): T | undefined;
    nullable(isNullable?: boolean): this;
    required(message?: MixedLocale['required']): this;
    notRequired(): this;
    defined(): this;
    typeError(message: LocaleValue): this;
    oneOf(arrayOfValues: T[], message?: MixedLocale['oneOf']): this;
    equals(arrayOfValues: T[], message?: MixedLocale['oneOf']): this;
    notOneOf(arrayOfValues: T[], message?: MixedLocale['notOneOf']): this;
    /** @仅保留了类型友好的用法 */
    when(builder: (value: T, schema: this) => this): this;
    test(test: SchemaTestOptions<this, T>['test'] | RegExp, message?: SchemaTestOptions<this, T>['message']): this;
    test<TParams = {}>(options: SchemaTestOptions<this, T, TParams>): this;
    transform(transformer: (this: this, currentValue: T, originalValue: T) => T): this;
}

declare function number<T extends number = number>(): NumberSchema<T>;

declare interface NumberLocale {
    min: LocaleValue<{
        min: number;
    }>;
    max: LocaleValue<{
        max: number;
    }>;
    lessThan: LocaleValue<{
        less: number;
    }>;
    moreThan: LocaleValue<{
        more: number;
    }>;
    positive: LocaleValue<{
        more: number;
    }>;
    negative: LocaleValue<{
        less: number;
    }>;
    integer: LocaleValue;
    id: LocaleValue;
}

declare interface NumberSchema<T extends number = number> extends MixedSchema<T> {
    min(limit: number | Ref, message?: NumberLocale['min']): this;
    max(limit: number | Ref, message?: NumberLocale['max']): this;
    lessThan(max: number | Ref, message?: NumberLocale['lessThan']): this;
    moreThan(min: number | Ref, message?: NumberLocale['moreThan']): this;
    positive(message?: NumberLocale['positive']): this;
    negative(message?: NumberLocale['negative']): this;
    integer(message?: NumberLocale['integer']): this;
    id(message?: NumberLocale['id']): this;
    truncate(): this;
    round(type?: 'floor' | 'ceil' | 'trunc' | 'round'): this;
}

declare function object<T extends {} = {}>(fields?: GetObjectSchema<T>): ObjectSchema<T>;

declare interface ObjectLocale {
    noUnknown: LocaleValue<{
        unknown: string;
    }>;
}

declare interface ObjectSchema<T extends {} = {}> extends MixedSchema<T> {
    shape(fields: GetObjectSchema<T>, noSortEdges?: Array<[string, string]>): this;
    from(fromKey: keyof T, toKey: string, alias?: boolean): this;
    noUnknown(onlyKnownKeys?: boolean, message?: ObjectLocale['noUnknown']): this;
    camelCase(): this;
    constantCase(): this;
    validateInOrder(value: T, options?: SchemaValidateOptions): Promise<T>;
    validateInOrderSync(value: T, options?: SchemaValidateOptions): T;
}

/** Gets keys of an object which are optional */
declare type OptionalKeys<T> = {
    [K in keyof T]-?: undefined extends {
        [K2 in keyof T]: K2;
    }[K]
    ? K
    : never;
}[keyof T];

/** Pick all properties of given type in object type */
declare type PickProperties<T, P> = Pick<
T,
    {
    [K in keyof T]: T[K] extends P ? K : never;
}[keyof T]
>;

/** Essentials */
declare type Primitive = string | number | boolean | bigint | symbol | undefined | null;

declare function printValue(value: string, quoteStrings: boolean): string;

declare function reach<T>(schema: ObjectSchema<T>, path: string, value?: T, context?: {}): MixedSchema;

declare interface Ref {
    readonly __isYupRef: true;
}

declare function ref<T>(path: string, options?: RefOptions): Ref;

declare interface RefOptions {
    contextPrefix?: string;
}

/**
 * 独立渲染一个组件在 document.body 下，常应用于弹窗类组件。
 *
 * @param Component 要渲染的组件
 * @param initialProps 初始属性
 * @param injectCallbacks 回调函数注入
 */
export declare function renderComponent<TComponent extends React_2.ComponentType<any>>(Component: TComponent, initialProps: React_2.ComponentProps<TComponent>, injectCallbacks?: PickProperties<React_2.ComponentProps<TComponent>, Function | undefined>): RenderComponentResult<TComponent>;

export declare function RenderComponentContainer(): React_2.FunctionComponentElement<{
    children: any[];
}>;

export declare interface RenderComponentResult<TComponent extends React_2.ComponentType<any>> {
    /**
     * 增量重渲染，新属性将与增量属性合并并成为新的增量属性。
     *
     * @param props 新属性
     */
    incrementalRerender(props: Partial<React_2.ComponentProps<TComponent>>): void;
    /**
     * 部分重渲染，新属性将与初始属性合并。
     *
     * @param props 新属性
     */
    partialRerender(props: Partial<React_2.ComponentProps<TComponent>>): void;
    /**
     * 完全重渲染，新属性将直接作为全部属性传给组件。
     *
     * @param props 新属性
     */
    fullRerender(props: React_2.ComponentProps<TComponent>): void;
    /**
     * 销毁组件并移除 DOM 节点。
     */
    destroy(): void;
}

declare interface SchemaDescription {
    type: string;
    label: string;
    meta: {};
    tests: Array<{
        name: string;
        params: {};
    }>;
}

declare interface SchemaTestOptions<TSchema, TValue, TParams = {}> {
    name: string;
    message: LocaleValue<TParams>;
    test: (this: {
        path: string;
        schema: TSchema;
        options: SchemaValidateOptions;
        parent: any;
        createError: (options: {
            path: string;
            message: LocaleValue;
            params?: TParams;
        }) => ValidationError;
    }, value: TValue) => boolean | Promise<boolean>;
    params?: TParams;
    exclusive?: boolean;
}

declare interface SchemaValidateOptions {
    strict?: boolean;
    abortEarly?: boolean;
    stripUnknown?: boolean;
    recursive?: boolean;
    context?: {};
}

declare function setLocale(locale: DeepPartial<Locale>): void;

declare function string<T extends string = string>(): StringSchema<T>;

declare interface StringLocale {
    length: LocaleValue<{
        length: number;
    }>;
    min: LocaleValue<{
        min: number;
    }>;
    max: LocaleValue<{
        max: number;
    }>;
    matches: LocaleValue<{
        regex: RegExp;
    }>;
    email: LocaleValue<{
        regex: RegExp;
    }>;
    url: LocaleValue<{
        regex: RegExp;
    }>;
    trim: LocaleValue;
    lowercase: LocaleValue;
    uppercase: LocaleValue;
    chineseMobilePhoneNumber: LocaleValue;
    chineseIDCardNumber: LocaleValue;
}

declare interface StringSchema<T extends string = string> extends MixedSchema<T> {
    required(message?: MixedLocale['required']): this;
    length(limit: number | Ref, message?: StringLocale['length']): this;
    min(limit: number | Ref, message?: StringLocale['min']): this;
    max(limit: number | Ref, message?: StringLocale['max']): this;
    matches(regex: RegExp, message?: StringLocale['matches']): this;
    matches(regex: RegExp, options?: {
        excludeEmptyString?: boolean;
        message?: StringLocale['matches'];
    }): this;
    email(message?: StringLocale['email']): this;
    url(message?: StringLocale['url']): this;
    ensure(): this;
    trim(message?: StringLocale['trim']): this;
    lowercase(message?: StringLocale['lowercase']): this;
    uppercase(message?: StringLocale['uppercase']): this;
    chineseMobilePhoneNumber(message?: StringLocale['chineseMobilePhoneNumber']): this;
    chineseIDCardNumber(message?: StringLocale['chineseIDCardNumber']): this;
}

export { useAsync }

export { useAsyncFn }

export { useAsyncRetry }

export { useAudio }

export { useBattery }

export { useBeforeUnload }

export { useBoolean }

/**
 * 获取类名字符串。
 *
 * @public
 * @param getClassValues 获取类名列表函数
 * @param deps 当依赖变更时重新获取
 * @returns 返回类名字符串
 * @example
 * ```typescript
 * const [mini, setMini] = useState(true)
 * const buttonClassName = useClassName(() => [
 *   'ui-btn',
 *   mini && 'ui-btn_mini',
 * ], [mini])
 * console.log(buttonClassName) // => 'ui-btn ui-btn_mini'
 * setMini(false)
 * console.log(buttonClassName) // => 'ui-btn'
 * ```
 */
export declare function useClassName(getClassValues: () => any[] | undefined, deps: DependencyList): string | undefined;

export { useClickAway }

/**
 * 受控值。
 *
 * @param props 组件的属性
 * @param options 选项
 */
export declare function useControllableValue<TProps, TDefaultValuePropName extends keyof TProps, TValuePropName extends keyof TProps, TCallbackPropName extends keyof TProps, TDefaultValue extends TProps[TValuePropName]>(props: TProps, options: UseControllableValueOptions<TProps, TDefaultValuePropName, TValuePropName, TCallbackPropName, TDefaultValue>): UseControllableValueResult<TProps, TValuePropName, TCallbackPropName, TDefaultValue>;

export declare type UseControllableValueOptions<TProps, TDefaultValuePropName extends keyof TProps, TValuePropName extends keyof TProps, TCallbackPropName extends keyof TProps, TDefaultValue extends TProps[TValuePropName]> = {
    /**
     * 默认值的属性名。
     */
    defaultValuePropName: TDefaultValuePropName;
    /**
     * 值的属性名。
     */
    valuePropName: TValuePropName;
    /**
     * 值改变时的回调函数的属性名。
     */
    callbackPropName: TCallbackPropName;
    /**
     * 默认值。
     */
    defaultValue?: TDefaultValue;
    /**
     * 是否总是更新值。
     */
    alwaysUpdateValue?: boolean;
};

export declare type UseControllableValueResult<TProps, TValuePropName extends keyof TProps, TCallbackPropName extends keyof TProps, TDefaultValue extends TProps[TValuePropName]> = [
TDefaultValue extends undefined ? TProps[TValuePropName] : Defined<TProps[TValuePropName]>,
Defined<TProps[TCallbackPropName]>,
() => void
];

export { useCookie }

export { useCopyToClipboard }

export { useCounter }

export { useCss }

export { useCustomCompareEffect }

export { useDebounce }

export { useDeepCompareEffect }

export { useDefault }

export { useDrop }

export { useDropArea }

export { useEffectOnce }

export { useEnsuredForwardedRef }

/**
 * 获取运行环境信息。
 *
 * @returns 返回运行环境信息
 */
export declare function useEnvironment(): GetEnvironmentResult;

export { useError }

export { useEvent }

export { useFavicon }

export { useFirstMountState }

export { useFullscreen }

export { useGeolocation }

export { useGetSet }

export { useGetSetState }

export { useHarmonicIntervalFn }

export { useHash }

export declare function useHover(options?: UseHoverOptions): UseHoverResult;

export { useHoverDirty }

export declare interface UseHoverOptions {
    /**
     * 悬停开始后多久开启悬停态，单位为毫秒。
     *
     * @default 50
     */
    hoverStartDelay?: number;
    /**
     * 悬停结束后多久关闭悬停态，单位为毫秒。
     *
     * @default 400
     */
    hoverEndDelay?: number;
}

export declare interface UseHoverResult {
    /**
     * 当前的悬停态。
     */
    hovering: boolean;
    /**
     * 开始悬停。
     */
    startHover: () => any;
    /**
     * 结束悬停。
     */
    endHover: () => any;
}

export { useIdle }

export { useIntersection }

/**
 * 以一定的间隔时间重复调用某函数，并返回调用结果。
 *
 * @param callback 回调函数
 * @param delay 间隔时间（毫秒），非数字时将不调用或停止调用函数
 * @param duration 持续时间（毫秒）
 * @returns 返回调用结果
 */
export declare function useInterval<TResult>(callback: () => TResult, delay: any, duration?: number): UseIntervalResult<TResult>;

export declare type UseIntervalResult<TResult> = [
TResult | undefined,
    {
    start: (delay?: number, duration?: number) => void;
    stop: () => void;
}
];

export { useIsomorphicLayoutEffect }

export { useKey }

export { useKeyPress }

export { useKeyPressEvent }

export { useLatest }

export { useLifecycles }

export { useList }

/**
 * 数据加载。
 *
 * @public
 * @param service 数据加载服务
 * @param deps 依赖若发生变化则从首页重新加载数据
 * @returns 返回结果
 */
export declare function useLoadMore<TItem>(service: UseLoadMoreService<TItem>, deps: DependencyList): UseLoadMoreResult<TItem>;

/**
 * 加载更多结果。
 *
 * @public
 */
export declare interface UseLoadMoreResult<TItem> {
    /** 当前页码 */
    pageNumber: number;
    /** 已加载的数据 */
    data?: TItem[];
    /** 总数据量 */
    total: number;
    /** 是否正在加载数据 */
    loading: boolean;
    /** 是否正在加载初始数据 */
    initialLoading: boolean;
    /** 是否正在加载更多数据 */
    incrementalLoading: boolean;
    /** 数据是否已加载完 */
    noMore: boolean;
    /** 加载更多数据 */
    loadMore: () => Promise<void>;
    /** 从首页重新加载数据 */
    reload: () => Promise<void>;
    /** 设置数据 */
    setData: Dispatch<SetStateAction<TItem[]>>;
}

/**
 * 加载服务。
 *
 * @public
 */
export declare interface UseLoadMoreService<TItem> {
    (payload: UseLoadMoreServicePayload): Promise<UseLoadMoreServiceResult<TItem>>;
}

/**
 * 加载服务载荷。
 *
 * @public
 */
export declare interface UseLoadMoreServicePayload {
    /** 已加载的数据量 */
    offset: number;
    /** 当前页码 */
    pageNumber: number;
}

/**
 * 加载服务结果。
 *
 * @public
 */
export declare type UseLoadMoreServiceResult<TItem> = TItem[] | {
    /** 总数据量 */
    total: number;
    /** 当前页数据 */
    data: TItem[];
} | {
    /** 总数据量 */
    total: number;
    /** 当前页数据 */
    list: TItem[];
};

export declare function useLocalStorage<S>(key: string): UseLocalStorageResult<S | undefined>;

export declare function useLocalStorage<S>(key: string, initialState: S): UseLocalStorageResult<S>;

export declare type UseLocalStorageResult<S> = readonly [
S,
Dispatch<SetStateAction<S>>,
() => void
];

export { useLocation }

export { useLockBodyScroll }

export { useLogger }

export { useLongPress }

export { useMap }

export { useMeasure }

export { useMedia }

export { useMediaDevices }

export { useMediatedState }

export { useMethods }

export { useMotion }

export { useMount }

export { useMountedState }

export { useMouse }

export { useMouseHovered }

export { useMouseWheel }

export { useMultiStateValidator }

export { useNetworkState }

export { useNumber }

export { useObservable }

export { useOrientation }

export { usePageLeave }

export { usePermission }

export { usePrevious }

export { usePreviousDistinct }

export { usePromise }

export { useQueue }

export { useRaf }

export { useRafLoop }

export { useRafState }

/**
 * 立即触发一次回调，并且每当到达页面底部时触发回调。
 *
 * @public
 * @param callback 回调
 * @param offset 触底偏移量
 * @returns 返回
 */
export declare function useReachBottom<T extends HTMLElement>(callback: () => any, offset?: number): MutableRefObject<T>;

export { useRendersCount }

export { useScratch }

export { useScroll }

export { useScrollbarWidth }

export { useScrolling }

/**
 * 滚动数据加载。
 *
 * @public
 * @param service 数据加载服务
 * @param deps 依赖，依赖若发生变化则从首页重新加载数据
 * @param options 滚动选项
 * @returns 返回结果
 */
export declare function useScrollLoadMore<TItem>(service: UseLoadMoreService<TItem>, deps: DependencyList, options?: UseScrollLoadMoreOptions): UseLoadMoreResult<TItem>;

/**
 * @public
 */
export declare interface UseScrollLoadMoreOptions {
    /**
     * 距离底部偏移量（单位：像素），小于该值时触发加载。
     *
     * @default 0
     */
    offset?: number;
    /**
     * 滚动容器，默认以窗口作为滚动容器。
     *
     * @default window
     */
    containerRef?: ReturnType<typeof useReachBottom>;
}

export { useSearchParam }

export { useSessionStorage }

export { useSet }

export { useSetState }

export { useShallowCompareEffect }

export { useSize }

export { useSlider }

export { useSpeech }

/**
 * 暂存状态。
 */
export declare function useStaged<T>(value: T, setValue: (value: T) => void): [
T,
    {
    set: (value: T) => void;
    commit: () => void;
    reset: () => void;
}
];

export { useStartTyping }

export { useStateList }

export { useStateValidator }

/**
 * 给 useState 插上依赖的翅膀。依赖变化时会更新状态。
 *
 * @param state 状态
 * @param deps 依赖
 * @returns 返回结果同 useState
 */
export declare function useStateWithDeps<S>(state: S | (() => S), deps: React_2.DependencyList): [S, React_2.Dispatch<React_2.SetStateAction<S>>];

export { useStateWithHistory }

export { useThrottle }

export { useThrottleFn }

export { useTimeout }

export { useTimeoutFn }

export { useTitle }

/**
 * 布尔值切换器。
 *
 * @public
 * @param initialValue 初始值
 * @returns 返回结果和操作
 * @example
 * ```typescript
 * const [value, toggle] = useToggle(false) // value: false
 * toggle() // value: true
 * toggle.set(false) // value: false
 * toggle.true() // => value: true
 * toggle.false() // => value: false
 * ```
 */
export declare function useToggle(initialValue: boolean): UseToggleResult;

/**
 * @public
 */
export declare type UseToggleResult = [
boolean,
    {
    (): void;
    set(value: boolean): void;
    true(): void;
    false(): void;
}
];

export { useTween }

export { useUnmount }

export { useUnmountPromise }

export { useUpdate }

export { useUpdateEffect }

export { useUpsert }

export declare function useValidator<T>(data: T, dataDeps: DependencyList, schema: UseValidatorSchema<T>, schemaDeps?: DependencyList): UseValidatorResult<T>;

export declare function useValidator<T>(data: T, schema: UseValidatorSchema<T>, schemaDeps?: DependencyList): UseValidatorResult<T>;

export declare interface UseValidatorResult<T> {
    data: T;
    valid: boolean;
    error?: yup.ValidationError | undefined;
}

export declare type UseValidatorSchema<T> = (yup: typeof yup) => T extends string ? yup.StringSchema<T> : T extends number ? yup.NumberSchema<T> : T extends boolean ? yup.BooleanSchema<T> : T extends Array<infer X> ? yup.ArraySchema<X> : T extends AnyObject_2 ? yup.ObjectSchema<T> | yup.GetObjectSchema<T> : yup.MixedSchema<T>;

export { useVibrate }

export { useVideo }

export { useWindowScroll }

export { useWindowSize }

declare class ValidationError {
    value: any;
    path: string;
    type: string;
    errors: string[];
    inner: any[];
    message: string;
    stack?: any;
    static isError<T>(err: T): boolean;
    static formatError(message: LocaleValue, params: LocaleValueFnParams): string;
}

declare namespace yup {
    export {
        addMethod,
        array,
        ArraySchema,
        boolean,
        BooleanSchema,
        date,
        DateSchema,
        getLocale,
        lazy,
        Lazy,
        LocaleValueFnParams,
        LocaleValueFn,
        LocaleValue,
        MixedLocale,
        StringLocale,
        NumberLocale,
        DateLocale,
        BooleanLocale,
        ObjectLocale,
        ArrayLocale,
        Locale,
        mixed,
        SchemaDescription,
        SchemaValidateOptions,
        SchemaTestOptions,
        MixedSchema,
        GetSchema,
        GetObjectSchema,
        number,
        NumberSchema,
        object,
        ObjectSchema,
        printValue,
        reach,
        ref,
        Ref,
        RefOptions,
        setLocale,
        string,
        StringSchema,
        ValidationError
    }
}

export { }
