"use strict";

exports.__esModule = true;
exports.base64Encode = base64Encode;
exports.base64Decode = base64Decode;
exports.base64UrlEncode = base64UrlEncode;
exports.base64UrlDecode = base64UrlDecode;

/**
 * base64.js
 * Dan Kogai (https://github.com/dankogai)
 * Licensed under the BSD 3-Clause License
 * https://github.com/dankogai/js-base64/blob/master/LICENSE.md
 *
 * Modified by Jay Fong
 */
// ‰ΩøÁî® global['Buffer'] ËÄå‰∏çÊòØ Buffer ‰ª•Èò≤Ê≠¢ webpack Á≠âÂ∑•ÂÖ∑Ëá™Âä®Âä† polyfill
var canUseBufferFrom = typeof global !== 'undefined' && // @ts-expect-error https://github.com/microsoft/TypeScript/issues/39504
typeof global['Buffer'] !== 'undefined' && // @ts-expect-error https://github.com/microsoft/TypeScript/issues/39504
typeof global['Buffer']['from'] === 'function';
var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var base64Table = {};

for (var i = 0; i < base64Chars.length; i++) {
  base64Table[base64Chars[i]] = i;
}

var fromCharCode = String.fromCharCode; // binaryToAscii

function binaryToAsciiReplacer(str) {
  var padlen = [0, 2, 1][str.length % 3];
  var ord = str.charCodeAt(0) << 16 | (str.length > 1 ? str.charCodeAt(1) : 0) << 8 | (str.length > 2 ? str.charCodeAt(2) : 0);
  var chars = [base64Chars.charAt(ord >>> 18), base64Chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : base64Chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : base64Chars.charAt(ord & 63)];
  return chars.join('');
}

var binaryToAscii = typeof window !== 'undefined' && window.btoa || function (value) {
  return value.replace(/[\s\S]{1,3}/g, binaryToAsciiReplacer);
}; // utf8ToBinary


var utf8ToBinaryRegExp = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;

function utf8ToBinaryReplacer(str) {
  if (str.length < 2) {
    var _cc = str.charCodeAt(0);

    return _cc < 0x80 ? str : _cc < 0x800 ? fromCharCode(0xc0 | _cc >>> 6) + fromCharCode(0x80 | _cc & 0x3f) : fromCharCode(0xe0 | _cc >>> 12 & 0x0f) + fromCharCode(0x80 | _cc >>> 6 & 0x3f) + fromCharCode(0x80 | _cc & 0x3f);
  }

  var cc = 0x10000 + (str.charCodeAt(0) - 0xd800) * 0x400 + (str.charCodeAt(1) - 0xdc00);
  return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
}

var utf8ToBinary = function utf8ToBinary(value) {
  return value.replace(utf8ToBinaryRegExp, utf8ToBinaryReplacer);
}; // utf8ToAscii


var utf8ToAscii = function utf8ToAscii(value) {
  return binaryToAscii(utf8ToBinary(value));
}; // asciiToBinary


function asciiToBinaryReplacer(str) {
  var len = str.length;
  var padlen = len % 4;
  var n = (len > 0 ? base64Table[str.charAt(0)] << 18 : 0) | (len > 1 ? base64Table[str.charAt(1)] << 12 : 0) | (len > 2 ? base64Table[str.charAt(2)] << 6 : 0) | (len > 3 ? base64Table[str.charAt(3)] : 0);
  var chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];
  chars.length -= [0, 0, 2, 1][padlen];
  return chars.join('');
}

var asciiToBinary = typeof window !== 'undefined' && window.atob || function (value) {
  return value.replace(/\S{1,4}/g, asciiToBinaryReplacer);
}; // binaryToUtf8


var binaryToUtf8RegExp = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;

function binaryToUtf8Replacer(str) {
  switch (str.length) {
    case 4:
      var cp = (0x07 & str.charCodeAt(0)) << 18 | (0x3f & str.charCodeAt(1)) << 12 | (0x3f & str.charCodeAt(2)) << 6 | 0x3f & str.charCodeAt(3);
      var offset = cp - 0x10000;
      return fromCharCode((offset >>> 10) + 0xd800) + fromCharCode((offset & 0x3ff) + 0xdc00);

    case 3:
      return fromCharCode((0x0f & str.charCodeAt(0)) << 12 | (0x3f & str.charCodeAt(1)) << 6 | 0x3f & str.charCodeAt(2));

    default:
      return fromCharCode((0x1f & str.charCodeAt(0)) << 6 | 0x3f & str.charCodeAt(1));
  }
}

var binaryToUtf8 = function binaryToUtf8(value) {
  return value.replace(binaryToUtf8RegExp, binaryToUtf8Replacer);
}; // asciiToUtf8


var asciiToUtf8 = function asciiToUtf8(value) {
  return binaryToUtf8(asciiToBinary(value.replace(/=+$/, '')));
};
/**
 * Â∞ÜÁªôÂÆöÁöÑ UTF8 Â≠óÁ¨¶‰∏≤ÁºñÁ†Å‰∏∫ base64 Â≠óÁ¨¶‰∏≤„ÄÇ
 *
 * @public
 * @param value Ë¶ÅÁºñÁ†ÅÁöÑ UTF8 Â≠óÁ¨¶‰∏≤
 * @returns ËøîÂõûÁºñÁ†ÅÂêéÁöÑ base64 Â≠óÁ¨¶‰∏≤
 * @example
 * ```typescript
 * base64Encode('v') // => 'dg=='
 * base64Encode('Èæô') // => '6b6Z'
 * base64Encode('üê±') // => '8J+QsQ=='
 * ```
 */


function base64Encode(value) {
  if (canUseBufferFrom) {
    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/39504
    return global['Buffer']['from'](value, 'utf8').toString('base64');
  }

  return utf8ToAscii(value);
}
/**
 * Â∞ÜÁªôÂÆöÁöÑ base64 Â≠óÁ¨¶‰∏≤Ëß£Á†Å‰∏∫ UTF8 Â≠óÁ¨¶‰∏≤„ÄÇ
 *
 * @public
 * @param value Ë¶ÅËß£Á†ÅÁöÑ base64 Â≠óÁ¨¶‰∏≤
 * @returns ËøîÂõûËß£Á†ÅÂêéÁöÑ UTF8 Â≠óÁ¨¶‰∏≤
 * @example
 * ```typescript
 * base64Decode('dg==') // => 'v'
 * base64Decode('6b6Z') // => 'Èæô'
 * base64Decode('8J+QsQ==') // => 'üê±'
 * ```
 */


function base64Decode(value) {
  if (canUseBufferFrom) {
    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/39504
    return global['Buffer']['from'](value, 'base64').toString('utf8');
  }

  return asciiToUtf8(value);
}
/**
 * Â∞ÜÁªôÂÆöÁöÑ UTF8 Â≠óÁ¨¶‰∏≤ÁºñÁ†Å‰∏∫ URL ÂÆâÂÖ®ÁöÑ base64url Â≠óÁ¨¶‰∏≤„ÄÇ
 *
 * @public
 * @param value Ë¶ÅÁºñÁ†ÅÁöÑ UTF8 Â≠óÁ¨¶‰∏≤
 * @returns ËøîÂõûÁºñÁ†ÅÂêéÁöÑ base64url Â≠óÁ¨¶‰∏≤
 * @example
 * ```typescript
 * base64UrlEncode('v') // => 'dg'
 * base64UrlEncode('Èæô') // => '6b6Z'
 * base64UrlEncode('üê±') // => '8J-QsQ'
 * ```
 */


function base64UrlEncode(value) {
  return base64Encode(value).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
/**
 * Â∞ÜÁªôÂÆöÁöÑ base64url Â≠óÁ¨¶‰∏≤Ëß£Á†Å‰∏∫ UTF8 Â≠óÁ¨¶‰∏≤„ÄÇ
 *
 * @public
 * @param value Ë¶ÅËß£Á†ÅÁöÑ base64url Â≠óÁ¨¶‰∏≤
 * @returns ËøîÂõûËß£Á†ÅÂêéÁöÑ UTF8 Â≠óÁ¨¶‰∏≤
 * @example
 * ```typescript
 * base64UrlDecode('dg') // => 'v'
 * base64UrlDecode('6b6Z') // => 'Èæô'
 * base64UrlDecode('8J-QsQ') // => 'üê±'
 * ```
 */


function base64UrlDecode(value) {
  return base64Decode(value.replace(/-/g, '+').replace(/_/g, '/'));
}