/**
 * 类型工具库。
 *
 * @packageDocumentation
 */

declare type AnyArray_2<T = any> = Array<T> | ReadonlyArray<T>;
export { AnyArray_2 as AnyArray }

/**
 * 任意异步函数。
 *
 * @public
 */
export declare type AnyAsyncFunction = Record<any, any> & {
    (...args: any[]): Promise<any>;
};

/**
 * 任意函数。
 *
 * @public
 */
declare type AnyFunction_2 = Record<any, any> & {
    (...args: any[]): any;
};
export { AnyFunction_2 as AnyFunction }

/**
 * 任意对象。
 *
 * @public
 */
declare type AnyObject_2 = Record<any, any>;
export { AnyObject_2 as AnyObject }

/**
 Methods to exclude.
 */
declare type ArrayLengthMutationKeys = 'splice' | 'push' | 'pop' | 'shift' | 'unshift';

declare type AsyncFunction = (...args: any[]) => Promise<unknown>;

/**
 Create an async version of the given function type, by boxing the return type in `Promise` while keeping the same parameter types.

 Use-case: You have two functions, one synchronous and one asynchronous that do the same thing. Instead of having to duplicate the type definition, you can use `Asyncify` to reuse the synchronous type.

 @example
 ```
 import {Asyncify} from 'type-fest';

 // Synchronous function.
 function getFooSync(someArg: SomeType): Foo {
 	// …
 }

 type AsyncifiedFooGetter = Asyncify<typeof getFooSync>;
 //=> type AsyncifiedFooGetter = (someArg: SomeType) => Promise<Foo>;

 // Same as `getFooSync` but asynchronous.
 const getFooAsync: AsyncifiedFooGetter = (someArg) => {
 	// TypeScript now knows that `someArg` is `SomeType` automatically.
 	// It also knows that this function must return `Promise<Foo>`.
 	// If you have `@typescript-eslint/promise-function-async` linter rule enabled, it will even report that "Functions that return promises must be async.".

 	// …
 }
 ```

 @category Utilities
 */
export declare type Asyncify<Fn extends (...args: any[]) => any> = SetReturnType<Fn, Promise<PromiseValue<ReturnType<Fn>>>>;

/** Useful as a return type in interfaces or abstract classes with missing implementation */
export declare type AsyncOrSync<T> = PromiseLike<T> | T;

/**
 Unwrap the return type of a function that returns a `Promise`.

 There has been [discussion](https://github.com/microsoft/TypeScript/pull/35998) about implementing this type in TypeScript.

 @example
 ```ts
 import {AsyncReturnType} from 'type-fest';
 import {asyncFunction} from 'api';

 // This type resolves to the unwrapped return type of `asyncFunction`.
 type Value = AsyncReturnType<typeof asyncFunction>;

 async function doSomething(value: Value) {}

 asyncFunction().then(value => doSomething(value));
 ```

 @category Utilities
 */
export declare type AsyncReturnType<Target extends AsyncFunction> = PromiseValue<ReturnType<Target>>;

/** Combination of DeepPartial and DeepWritable */
export declare type Buildable<T> = PartialDeep<WritableDeep<T>>;

declare type Builtin = Primitive_2 | Function | Date | Error | RegExp;

/**
 Convert a string literal to camel-case.

 This can be useful when, for example, converting some kebab-cased command-line flags or a snake-cased database result.

 @example
 ```
 import {CamelCase} from 'type-fest';

 // Simple

 const someVariable: CamelCase<'foo-bar'> = 'fooBar';

 // Advanced

 type CamelCasedProperties<T> = {
 	[K in keyof T as CamelCase<K>]: T[K]
 };

 interface RawOptions {
 	'dry-run': boolean;
 	'full_family_name': string;
 	foo: number;
 	BAR: string;
 	QUZ_QUX: number;
 	'OTHER-FIELD': boolean;
 }

 const dbResult: CamelCasedProperties<ModelProps> = {
 	dryRun: true,
 	fullFamilyName: 'bar.js',
 	foo: 123,
 	bar: 'foo',
 	quzQux: 6,
 	otherField: false
 };
 ```

 @category Template Literals
 */
export declare type CamelCase<K> = K extends string ? K extends Uppercase<K> ? CamelCaseStringArray<Split<Lowercase<K>, WordSeparators>> : CamelCaseStringArray<Split<K, WordSeparators>> : K;

/**
 Starts fusing the output of `Split<>`, an array literal of strings, into a camel-cased string literal.

 It's separate from `InnerCamelCaseStringArray<>` to keep a clean API outwards to the rest of the code.

 @see Split
 */
declare type CamelCaseStringArray<Parts extends string[]> =
	Parts extends [`${infer FirstPart}`, ...infer RemainingParts]
		? Uncapitalize<`${FirstPart}${InnerCamelCaseStringArray<RemainingParts, FirstPart>}`>
		: never;

/**
 Matches a [`class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).

 @category Basic
 */
export declare type Class<T, Arguments extends unknown[] = any[]> = Constructor<T, Arguments> & {prototype: T};

/**
 Matches a [`class` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).

 @category Basic
 */
declare type Constructor<T, Arguments extends unknown[] = any[]> = new(...arguments_: Arguments) => T;

declare type DeepOmitModify<T> =
| {
    [K in keyof T]: T[K] extends never ? any : T[K] extends object ? DeepOmitModify<T[K]> : never;
}
| Array<DeepOmitModify<T>>
| Promise<DeepOmitModify<T>>
| Set<DeepOmitModify<T>>
| ReadonlySet<DeepOmitModify<T>>
| WeakSet<DeepOmitModify<T>>
| Map<any, DeepOmitModify<T>>
| WeakMap<any, DeepOmitModify<T>>;

/**
 * 去除类型 T 中的 undefined。
 *
 * @public
 * @example
 * ```typescript
 * type X = string | undefined
 * type Y = Defined<X> // => string
 * ```
 */
export declare type Defined<T> = Exclude<T, undefined>;

/**
 Convert a string literal to a custom string delimiter casing.

 This can be useful when, for example, converting a camel-cased object property to an oddly cased one.

 @see KebabCase
 @see SnakeCase

 @example
 ```
 import {DelimiterCase} from 'type-fest';

 // Simple

 const someVariable: DelimiterCase<'fooBar', '#'> = 'foo#bar';

 // Advanced

 type OddlyCasedProperties<T> = {
 	[K in keyof T as DelimiterCase<K, '#'>]: T[K]
 };

 interface SomeOptions {
 	dryRun: boolean;
 	includeFile: string;
 	foo: number;
 }

 const rawCliOptions: OddlyCasedProperties<SomeOptions> = {
 	'dry#run': true,
 	'include#file': 'bar.js',
 	foo: 123
 };
 ```

 @category Template Literals
 */
export declare type DelimiterCase<Value, Delimiter extends string> = Value extends string
	? StringArrayToDelimiterCase<
		SplitIncludingDelimiters<Value, WordSeparators | UpperCaseCharacters>,
		WordSeparators,
		UpperCaseCharacters,
		Delimiter
	>
	: Value;

export declare type DotPath<T> = object extends T ? string : T extends readonly any[] ? Extract<keyof T, `${number}`> | SubKeys<T, Extract<keyof T, `${number}`>> : T extends object ? Extract<keyof T, string> | SubKeys<T, Extract<keyof T, string>> : never;

export declare type DotPathValue<T, Path extends string> = Path extends keyof T ? T[Path] : Path extends `${infer K}.${infer R}` ? K extends keyof T ? DotPathValue<T[K], R> : unknown : unknown;

/** Easily extract the type of a given array's elements */
export declare type ElementOf<T extends readonly any[]> = T extends readonly (infer ET)[] ? ET : never;

/**
 * 返回函数 T 第一个参数的类型。
 *
 * @public
 * @example
 * ```typescript
 * type F = (x: string, y: number) => any
 * type X = FirstParameter<F> // => string
 * ```
 */
export declare type FirstParameter<T extends (...args: any[]) => any> = Head<Parameters<T>>;

/**
 Create a type that represents an array of the given type and length. The array's length and the `Array` prototype methods that manipulate its length are excluded in the resulting type.

 Please participate in [this issue](https://github.com/microsoft/TypeScript/issues/26223) if you want to have a similiar type built into TypeScript.

 Use-cases:
 - Declaring fixed-length tuples or arrays with a large number of items.
 - Creating a range union (for example, `0 | 1 | 2 | 3 | 4` from the keys of such a type) without having to resort to recursive types.
 - Creating an array of coordinates with a static length, for example, length of 3 for a 3D vector.

 @example
 ```
 import {FixedLengthArray} from 'type-fest';

 type FencingTeam = FixedLengthArray<string, 3>;

 const guestFencingTeam: FencingTeam = ['Josh', 'Michael', 'Robert'];

 const homeFencingTeam: FencingTeam = ['George', 'John'];
 //=> error TS2322: Type string[] is not assignable to type 'FencingTeam'

 guestFencingTeam.push('Sam');
 //=> error TS2339: Property 'push' does not exist on type 'FencingTeam'
 ```

 @category Utilities
 */
export declare type FixedLengthArray<Element, Length extends number, ArrayPrototype = [Element, ...Element[]]> = Pick<
	ArrayPrototype,
	Exclude<keyof ArrayPrototype, ArrayLengthMutationKeys>
> & {
    	[index: number]: Element;
    	[Symbol.iterator]: () => IterableIterator<Element>;
    	readonly length: Length;
};

/** Functional programming essentials */
export declare type Head<T extends AnyArray_2> = T["length"] extends 0 ? never : T[0];

/**
 Step by step takes the first item in an array literal, formats it and adds it to a string literal, and then recursively appends the remainder.

 Only to be used by `CamelCaseStringArray<>`.

 @see CamelCaseStringArray
 */
declare type InnerCamelCaseStringArray<Parts extends any[], PreviousPart> =
	Parts extends [`${infer FirstPart}`, ...infer RemainingParts]
		? FirstPart extends undefined
			? ''
			: FirstPart extends ''
					? InnerCamelCaseStringArray<RemainingParts, PreviousPart>
					: `${PreviousPart extends '' ? FirstPart : Capitalize<FirstPart>}${InnerCamelCaseStringArray<RemainingParts, FirstPart>}`
		: '';

/**
 * 判断 `T` 是否是 `any` 类型。
 *
 * @public
 * @see https://stackoverflow.com/a/49928360
 * @example
 * ```typescript
 * type X = IsAny<any>
 * // => true
 * ```
 */
export declare type IsAny<T> = 0 extends 1 & T ? true : false;

declare type IsAny_2<T> = 0 extends (1 & T) ? true : false;

/**
 * 判断 `T` 是否是空数组。
 *
 * @public
 * @example
 * ```typescript
 * type X = IsEmptyArray<[]>
 * // => true
 * ```
 */
export declare type IsEmptyArray<T> = T extends any[] ? T extends NonEmptyArray<any> ? false : true : false;

/**
 * 判断 `T` 是否是空对象。
 *
 * @public
 * @example
 * ```typescript
 * type X = IsEmptyObject<{}>
 * // => true
 * ```
 */
export declare type IsEmptyObject<T> = T extends Object ? IsNever<keyof T> : false;

declare type IsEqualConsideringWritability<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
? true
: false;

declare type IsFullyWritable<T extends object> = IsEqualConsideringWritability<
    {
    [Q in keyof T]: T[Q];
},
Writable<
    {
    [Q in keyof T]: T[Q];
}
>
>;

/**
 * 判断 `T` 是否是 `never` 类型。
 *
 * @public
 * @example
 * ```typescript
 * type X = IsNever<never>
 * // => true
 * ```
 */
export declare type IsNever<T> = [T] extends [never] ? true : false;

declare type IsNever_2<T> = [T] extends [never] ? true : false;

declare type IsTuple<T> = T extends [infer A]
? T
: T extends [infer A, infer B]
? T
: T extends [infer A, infer B, infer C]
? T
: T extends [infer A, infer B, infer C, infer D]
? T
: T extends [infer A, infer B, infer C, infer D, infer E]
? T
: never;

declare type IsUnknown<T> = IsNever_2<T> extends false ? T extends unknown ? unknown extends T ? IsAny_2<T> extends false ? true : false : false : false : false;

/**
 Matches a JSON array.

 @category Basic
 */
export declare type JsonArray = JsonValue[];

/**
 Matches a JSON object.

 This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. Don't use this as a direct return type as the user would have to double-cast it: `jsonObject as unknown as CustomResponse`. Instead, you could extend your CustomResponse type from it to ensure your type only uses JSON-compatible types: `interface CustomResponse extends JsonObject { … }`.

 @category Basic
 */
export declare type JsonObject = {[Key in string]?: JsonValue};

/**
 Matches any valid JSON primitive value.

 @category Basic
 */
declare type JsonPrimitive = string | number | boolean | null;

/**
 Matches any valid JSON value.

 @see `Jsonify` if you need to transform a type to one that is assignable to `JsonValue`.

 @category Basic
 */
export declare type JsonValue = JsonPrimitive | JsonObject | JsonArray;

/**
 Convert a string literal to kebab-case.

 This can be useful when, for example, converting a camel-cased object property to a kebab-cased CSS class name or a command-line flag.

 @example
 ```
 import {KebabCase} from 'type-fest';

 // Simple

 const someVariable: KebabCase<'fooBar'> = 'foo-bar';

 // Advanced

 type KebabCasedProperties<T> = {
 	[K in keyof T as KebabCase<K>]: T[K]
 };

 interface CliOptions {
 	dryRun: boolean;
 	includeFile: string;
 	foo: number;
 }

 const rawCliOptions: KebabCasedProperties<CliOptions> = {
 	'dry-run': true,
 	'include-file': 'bar.js',
 	foo: 123
 };
 ```

 @category Template Literals
 */
export declare type KebabCase<Value> = DelimiterCase<Value, '-'>;

/**
 Allows creating a union type by combining primitive types and literal types without sacrificing auto-completion in IDEs for the literal type part of the union.

 Currently, when a union type of a primitive type is combined with literal types, TypeScript loses all information about the combined literals. Thus, when such type is used in an IDE with autocompletion, no suggestions are made for the declared literals.

 This type is a workaround for [Microsoft/TypeScript#29729](https://github.com/Microsoft/TypeScript/issues/29729). It will be removed as soon as it's not needed anymore.

 @example
 ```
 import {LiteralUnion} from 'type-fest';

 // Before

 type Pet = 'dog' | 'cat' | string;

 const pet: Pet = '';
 // Start typing in your TypeScript-enabled IDE.
 // You **will not** get auto-completion for `dog` and `cat` literals.

 // After

 type Pet2 = LiteralUnion<'dog' | 'cat', string>;

 const pet: Pet2 = '';
 // You **will** get auto-completion for `dog` and `cat` literals.
 ```

 @category Utilities
 */
export declare type LiteralUnion<
	LiteralType,
	BaseType extends Primitive,
> = LiteralType | (BaseType & {_?: never});

/** Merge 2 types, properties types from the latter override the ones defined on the former type */
export declare type Merge<M, N> = Omit<M, keyof N> & N;

/**
 * 非空数组类型。
 *
 * @public
 * @example
 * ```typescript
 * type X = NonEmptyArray<number>
 * const x: X = [] // => error
 * ```
 */
export declare type NonEmptyArray<T> = [T, ...T[]];

/** Like NonNullable but recursive */
export declare type NonNullableDeep<T> = T extends Builtin
? NonNullable<T>
: T extends Map<infer K, infer V>
? Map<NonNullableDeep<K>, NonNullableDeep<V>>
: T extends ReadonlyMap<infer K, infer V>
? ReadonlyMap<NonNullableDeep<K>, NonNullableDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<NonNullableDeep<K>, NonNullableDeep<V>>
: T extends Set<infer U>
? Set<NonNullableDeep<U>>
: T extends ReadonlySet<infer U>
? ReadonlySet<NonNullableDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<NonNullableDeep<U>>
: T extends Promise<infer U>
? Promise<NonNullableDeep<U>>
: T extends {}
? {
    [K in keyof T]: NonNullableDeep<T[K]>;
}
: NonNullable<T>;

/** Recursive nullable */
export declare type NullableDeep<T> = T extends Builtin
? T | null
: T extends Map<infer K, infer V>
? Map<NullableDeep<K>, NullableDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<NullableDeep<K>, NullableDeep<V>>
: T extends Set<infer U>
? Set<NullableDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<NullableDeep<U>>
: T extends Array<infer U>
? T extends IsTuple<T>
? {
    [K in keyof T]: NullableDeep<T[K]> | null;
}
: Array<NullableDeep<U>>
: T extends Promise<infer U>
? Promise<NullableDeep<U>>
: T extends {}
? {
    [K in keyof T]: NullableDeep<T[K]>;
}
: T | null;

/** Omit all properties of given type in object type */
export declare type OmitBy<T, P> = Pick<
T,
    {
    [K in keyof T]: T[K] extends P ? never : K;
}[keyof T]
>;

/** Recursively omit deep properties */
export declare type OmitDeep<T extends DeepOmitModify<Filter>, Filter> = T extends Builtin
? T
: T extends Map<infer KeyType, infer ValueType>
? ValueType extends DeepOmitModify<Filter>
? Map<KeyType, OmitDeep<ValueType, Filter>>
: T
: T extends ReadonlyMap<infer KeyType, infer ValueType>
? ValueType extends DeepOmitModify<Filter>
? ReadonlyMap<KeyType, OmitDeep<ValueType, Filter>>
: T
: T extends WeakMap<infer KeyType, infer ValueType>
? ValueType extends DeepOmitModify<Filter>
? WeakMap<KeyType, OmitDeep<ValueType, Filter>>
: T
: T extends Set<infer ItemType>
? ItemType extends DeepOmitModify<Filter>
? Set<OmitDeep<ItemType, Filter>>
: T
: T extends ReadonlySet<infer ItemType>
? ItemType extends DeepOmitModify<Filter>
? ReadonlySet<OmitDeep<ItemType, Filter>>
: T
: T extends WeakSet<infer ItemType>
? ItemType extends DeepOmitModify<Filter>
? WeakSet<OmitDeep<ItemType, Filter>>
: T
: T extends Array<infer ItemType>
? ItemType extends DeepOmitModify<Filter>
? Array<OmitDeep<ItemType, Filter>>
: T
: T extends Promise<infer ItemType>
? ItemType extends DeepOmitModify<Filter>
? Promise<OmitDeep<ItemType, Filter>>
: T
: {
    [K in Exclude<OptionalKeys<T>, keyof Filter>]+?: T[K];
} &
OmitBy<
    {
    [K in Extract<OptionalKeys<T>, keyof Filter>]+?: Filter[K] extends true
    ? never
    : T[K] extends DeepOmitModify<Filter[K]>
    ? OmitDeep<T[K], Filter[K]>
    : T[K];
},
never
> &
    {
    [K in Exclude<RequiredKeys<T>, keyof Filter>]: T[K];
} &
OmitBy<
    {
    [K in Extract<RequiredKeys<T>, keyof Filter>]: Filter[K] extends true
    ? never
    : T[K] extends DeepOmitModify<Filter[K]>
    ? OmitDeep<T[K], Filter[K]>
    : T[K];
},
never
>;

/** Similar to the builtin Omit, but checks the filter strictly. */
export declare type OmitStrict<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

/**
 * 同 `T | T[]`。
 *
 * @public
 * @example
 * ```typescript
 * type X = OneOrMore<number> // => number | number[]
 * ```
 */
export declare type OneOrMore<T> = T | T[];

/** Gets keys of an object which are optional */
export declare type OptionalKeys<T> = {
    [K in keyof T]-?: undefined extends {
        [K2 in keyof T]: K2;
    }[K]
    ? K
    : never;
}[keyof T];

export declare namespace PackageJson {
    	/**
     	A person who has been involved in creating or maintaining the package.
     	*/
    	export type Person =
    		| string
    		| {
        			name: string;
        			url?: string;
        			email?: string;
        		};

    	export type BugsLocation =
    		| string
    		| {
        			/**
         			The URL to the package's issue tracker.
         			*/
        			url?: string;

        			/**
         			The email address to which issues should be reported.
         			*/
        			email?: string;
        		};

    	export interface DirectoryLocations {
        		[directoryType: string]: unknown;

        		/**
         		Location for executable scripts. Sugar to generate entries in the `bin` property by walking the folder.
         		*/
        		bin?: string;

        		/**
         		Location for Markdown files.
         		*/
        		doc?: string;

        		/**
         		Location for example scripts.
         		*/
        		example?: string;

        		/**
         		Location for the bulk of the library.
         		*/
        		lib?: string;

        		/**
         		Location for man pages. Sugar to generate a `man` array by walking the folder.
         		*/
        		man?: string;

        		/**
         		Location for test files.
         		*/
        		test?: string;
        	}

    	export type Scripts = {
        		/**
         		Run **before** the package is published (Also run on local `npm install` without any arguments).
         		*/
        		prepublish?: string;

        		/**
         		Run both **before** the package is packed and published, and on local `npm install` without any arguments. This is run **after** `prepublish`, but **before** `prepublishOnly`.
         		*/
        		prepare?: string;

        		/**
         		Run **before** the package is prepared and packed, **only** on `npm publish`.
         		*/
        		prepublishOnly?: string;

        		/**
         		Run **before** a tarball is packed (on `npm pack`, `npm publish`, and when installing git dependencies).
         		*/
        		prepack?: string;

        		/**
         		Run **after** the tarball has been generated and moved to its final destination.
         		*/
        		postpack?: string;

        		/**
         		Run **after** the package is published.
         		*/
        		publish?: string;

        		/**
         		Run **after** the package is published.
         		*/
        		postpublish?: string;

        		/**
         		Run **before** the package is installed.
         		*/
        		preinstall?: string;

        		/**
         		Run **after** the package is installed.
         		*/
        		install?: string;

        		/**
         		Run **after** the package is installed and after `install`.
         		*/
        		postinstall?: string;

        		/**
         		Run **before** the package is uninstalled and before `uninstall`.
         		*/
        		preuninstall?: string;

        		/**
         		Run **before** the package is uninstalled.
         		*/
        		uninstall?: string;

        		/**
         		Run **after** the package is uninstalled.
         		*/
        		postuninstall?: string;

        		/**
         		Run **before** bump the package version and before `version`.
         		*/
        		preversion?: string;

        		/**
         		Run **before** bump the package version.
         		*/
        		version?: string;

        		/**
         		Run **after** bump the package version.
         		*/
        		postversion?: string;

        		/**
         		Run with the `npm test` command, before `test`.
         		*/
        		pretest?: string;

        		/**
         		Run with the `npm test` command.
         		*/
        		test?: string;

        		/**
         		Run with the `npm test` command, after `test`.
         		*/
        		posttest?: string;

        		/**
         		Run with the `npm stop` command, before `stop`.
         		*/
        		prestop?: string;

        		/**
         		Run with the `npm stop` command.
         		*/
        		stop?: string;

        		/**
         		Run with the `npm stop` command, after `stop`.
         		*/
        		poststop?: string;

        		/**
         		Run with the `npm start` command, before `start`.
         		*/
        		prestart?: string;

        		/**
         		Run with the `npm start` command.
         		*/
        		start?: string;

        		/**
         		Run with the `npm start` command, after `start`.
         		*/
        		poststart?: string;

        		/**
         		Run with the `npm restart` command, before `restart`. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
         		*/
        		prerestart?: string;

        		/**
         		Run with the `npm restart` command. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
         		*/
        		restart?: string;

        		/**
         		Run with the `npm restart` command, after `restart`. Note: `npm restart` will run the `stop` and `start` scripts if no `restart` script is provided.
         		*/
        		postrestart?: string;
        	} & Record<string, string>;

    	/**
     	Dependencies of the package. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or Git URL.
     	*/
    	export type Dependency = Record<string, string>;

    	/**
     	Conditions which provide a way to resolve a package entry point based on the environment.
     	*/
    	export type ExportCondition = LiteralUnion<
    		| 'import'
    		| 'require'
    		| 'node'
    		| 'deno'
    		| 'browser'
    		| 'electron'
    		| 'react-native'
    		| 'default',
    		string
    	>;

    	/**
     	Entry points of a module, optionally with conditions and subpath exports.
     	*/
    	export type Exports =
    	| string
    	| string[]
    	| {[key in ExportCondition]: Exports}
    	| {[key: string]: Exports}; // eslint-disable-line @typescript-eslint/consistent-indexed-object-style

    	export interface NonStandardEntryPoints {
        		/**
         		An ECMAScript module ID that is the primary entry point to the program.
         		*/
        		module?: string;

        		/**
         		A module ID with untranspiled code that is the primary entry point to the program.
         		*/
        		esnext?:
        		| string
        		| {
            			[moduleName: string]: string | undefined;
            			main?: string;
            			browser?: string;
            		};

        		/**
         		A hint to JavaScript bundlers or component tools when packaging modules for client side use.
         		*/
        		browser?:
        		| string
        		| Record<string, string | false>;

        		/**
         		Denote which files in your project are "pure" and therefore safe for Webpack to prune if unused.

         		[Read more.](https://webpack.js.org/guides/tree-shaking/)
         		*/
        		sideEffects?: boolean | string[];
        	}

    	export interface TypeScriptConfiguration {
        		/**
         		Location of the bundled TypeScript declaration file.
         		*/
        		types?: string;

        		/**
         		Version selection map of TypeScript.
         		*/
        		typesVersions?: Record<string, Record<string, string[]>>;

        		/**
         		Location of the bundled TypeScript declaration file. Alias of `types`.
         		*/
        		typings?: string;
        	}

    	/**
     	An alternative configuration for Yarn workspaces.
     	*/
    	export interface WorkspaceConfig {
        		/**
         		An array of workspace pattern strings which contain the workspace packages.
         		*/
        		packages?: WorkspacePattern[];

        		/**
         		Designed to solve the problem of packages which break when their `node_modules` are moved to the root workspace directory - a process known as hoisting. For these packages, both within your workspace, and also some that have been installed via `node_modules`, it is important to have a mechanism for preventing the default Yarn workspace behavior. By adding workspace pattern strings here, Yarn will resume non-workspace behavior for any package which matches the defined patterns.

         		[Read more](https://classic.yarnpkg.com/blog/2018/02/15/nohoist/)
         		*/
        		nohoist?: WorkspacePattern[];
        	}

    	/**
     	A workspace pattern points to a directory or group of directories which contain packages that should be included in the workspace installation process.

     	The patterns are handled with [minimatch](https://github.com/isaacs/minimatch).

     	@example
     	`docs` → Include the docs directory and install its dependencies.
     	`packages/*` → Include all nested directories within the packages directory, like `packages/cli` and `packages/core`.
     	*/
    	export type WorkspacePattern = string;

    	export interface YarnConfiguration {
        		/**
         		Used to configure [Yarn workspaces](https://classic.yarnpkg.com/docs/workspaces/).

         		Workspaces allow you to manage multiple packages within the same repository in such a way that you only need to run `yarn install` once to install all of them in a single pass.

         		Please note that the top-level `private` property of `package.json` **must** be set to `true` in order to use workspaces.
         		*/
        		workspaces?: WorkspacePattern[] | WorkspaceConfig;

        		/**
         		If your package only allows one version of a given dependency, and you’d like to enforce the same behavior as `yarn install --flat` on the command-line, set this to `true`.

         		Note that if your `package.json` contains `"flat": true` and other packages depend on yours (e.g. you are building a library rather than an app), those other packages will also need `"flat": true` in their `package.json` or be installed with `yarn install --flat` on the command-line.
         		*/
        		flat?: boolean;

        		/**
         		Selective version resolutions. Allows the definition of custom package versions inside dependencies without manual edits in the `yarn.lock` file.
         		*/
        		resolutions?: Dependency;
        	}

    	export interface JSPMConfiguration {
        		/**
         		JSPM configuration.
         		*/
        		jspm?: PackageJson;
        	}

    	/**
     	Type for [npm's `package.json` file](https://docs.npmjs.com/creating-a-package-json-file). Containing standard npm properties.
     	*/
    	export interface PackageJsonStandard {
        		/**
         		The name of the package.
         		*/
        		name?: string;

        		/**
         		Package version, parseable by [`node-semver`](https://github.com/npm/node-semver).
         		*/
        		version?: string;

        		/**
         		Package description, listed in `npm search`.
         		*/
        		description?: string;

        		/**
         		Keywords associated with package, listed in `npm search`.
         		*/
        		keywords?: string[];

        		/**
         		The URL to the package's homepage.
         		*/
        		homepage?: LiteralUnion<'.', string>;

        		/**
         		The URL to the package's issue tracker and/or the email address to which issues should be reported.
         		*/
        		bugs?: BugsLocation;

        		/**
         		The license for the package.
         		*/
        		license?: string;

        		/**
         		The licenses for the package.
         		*/
        		licenses?: Array<{
            			type?: string;
            			url?: string;
            		}>;

        		author?: Person;

        		/**
         		A list of people who contributed to the package.
         		*/
        		contributors?: Person[];

        		/**
         		A list of people who maintain the package.
         		*/
        		maintainers?: Person[];

        		/**
         		The files included in the package.
         		*/
        		files?: string[];

        		/**
         		Resolution algorithm for importing ".js" files from the package's scope.

         		[Read more.](https://nodejs.org/api/esm.html#esm_package_json_type_field)
         		*/
        		type?: 'module' | 'commonjs';

        		/**
         		The module ID that is the primary entry point to the program.
         		*/
        		main?: string;

        		/**
         		Standard entry points of the package, with enhanced support for ECMAScript Modules.

         		[Read more.](https://nodejs.org/api/esm.html#esm_package_entry_points)
         		*/
        		exports?: Exports;

        		/**
         		The executable files that should be installed into the `PATH`.
         		*/
        		bin?:
        		| string
        		| Record<string, string>;

        		/**
         		Filenames to put in place for the `man` program to find.
         		*/
        		man?: string | string[];

        		/**
         		Indicates the structure of the package.
         		*/
        		directories?: DirectoryLocations;

        		/**
         		Location for the code repository.
         		*/
        		repository?:
        		| string
        		| {
            			type: string;
            			url: string;

            			/**
             			Relative path to package.json if it is placed in non-root directory (for example if it is part of a monorepo).

             			[Read more.](https://github.com/npm/rfcs/blob/latest/implemented/0010-monorepo-subdirectory-declaration.md)
             			*/
            			directory?: string;
            		};

        		/**
         		Script commands that are run at various times in the lifecycle of the package. The key is the lifecycle event, and the value is the command to run at that point.
         		*/
        		scripts?: Scripts;

        		/**
         		Is used to set configuration parameters used in package scripts that persist across upgrades.
         		*/
        		config?: Record<string, unknown>;

        		/**
         		The dependencies of the package.
         		*/
        		dependencies?: Dependency;

        		/**
         		Additional tooling dependencies that are not required for the package to work. Usually test, build, or documentation tooling.
         		*/
        		devDependencies?: Dependency;

        		/**
         		Dependencies that are skipped if they fail to install.
         		*/
        		optionalDependencies?: Dependency;

        		/**
         		Dependencies that will usually be required by the package user directly or via another dependency.
         		*/
        		peerDependencies?: Dependency;

        		/**
         		Indicate peer dependencies that are optional.
         		*/
        		peerDependenciesMeta?: Record<string, {optional: true}>;

        		/**
         		Package names that are bundled when the package is published.
         		*/
        		bundledDependencies?: string[];

        		/**
         		Alias of `bundledDependencies`.
         		*/
        		bundleDependencies?: string[];

        		/**
         		Engines that this package runs on.
         		*/
        		engines?: {
            			[EngineName in 'npm' | 'node' | string]: string;
            		};

        		/**
         		@deprecated
         		*/
        		engineStrict?: boolean;

        		/**
         		Operating systems the module runs on.
         		*/
        		os?: Array<LiteralUnion<
        		| 'aix'
        		| 'darwin'
        		| 'freebsd'
        		| 'linux'
        		| 'openbsd'
        		| 'sunos'
        		| 'win32'
        		| '!aix'
        		| '!darwin'
        		| '!freebsd'
        		| '!linux'
        		| '!openbsd'
        		| '!sunos'
        		| '!win32',
        		string
        		>>;

        		/**
         		CPU architectures the module runs on.
         		*/
        		cpu?: Array<LiteralUnion<
        		| 'arm'
        		| 'arm64'
        		| 'ia32'
        		| 'mips'
        		| 'mipsel'
        		| 'ppc'
        		| 'ppc64'
        		| 's390'
        		| 's390x'
        		| 'x32'
        		| 'x64'
        		| '!arm'
        		| '!arm64'
        		| '!ia32'
        		| '!mips'
        		| '!mipsel'
        		| '!ppc'
        		| '!ppc64'
        		| '!s390'
        		| '!s390x'
        		| '!x32'
        		| '!x64',
        		string
        		>>;

        		/**
         		If set to `true`, a warning will be shown if package is installed locally. Useful if the package is primarily a command-line application that should be installed globally.

         		@deprecated
         		*/
        		preferGlobal?: boolean;

        		/**
         		If set to `true`, then npm will refuse to publish it.
         		*/
        		private?: boolean;

        		/**
         		A set of config values that will be used at publish-time. It's especially handy to set the tag, registry or access, to ensure that a given package is not tagged with 'latest', published to the global public registry or that a scoped module is private by default.
         		*/
        		publishConfig?: PublishConfig;

        		/**
         		Describes and notifies consumers of a package's monetary support information.

         		[Read more.](https://github.com/npm/rfcs/blob/latest/accepted/0017-add-funding-support.md)
         		*/
        		funding?: string | {
            			/**
             			The type of funding.
             			*/
            			type?: LiteralUnion<
            			| 'github'
            			| 'opencollective'
            			| 'patreon'
            			| 'individual'
            			| 'foundation'
            			| 'corporation',
            			string
            			>;

            			/**
             			The URL to the funding page.
             			*/
            			url: string;
            		};
        	}

    	export interface PublishConfig {
        		/**
         		Additional, less common properties from the [npm docs on `publishConfig`](https://docs.npmjs.com/cli/v7/configuring-npm/package-json#publishconfig).
         		*/
        		[additionalProperties: string]: unknown;

        		/**
         		When publishing scoped packages, the access level defaults to restricted. If you want your scoped package to be publicly viewable (and installable) set `--access=public`. The only valid values for access are public and restricted. Unscoped packages always have an access level of public.
         		*/
        		access?: 'public' | 'restricted';

        		/**
         		The base URL of the npm registry.

         		Default: `'https://registry.npmjs.org/'`
         		*/
        		registry?: string;

        		/**
         		The tag to publish the package under.

         		Default: `'latest'`
         		*/
        		tag?: string;
        	}
}

/**
 Type for [npm's `package.json` file](https://docs.npmjs.com/creating-a-package-json-file). Also includes types for fields used by other popular projects, like TypeScript and Yarn.

 @category Miscellaneous
 */
export declare type PackageJson =
PackageJson.PackageJsonStandard &
PackageJson.NonStandardEntryPoints &
PackageJson.TypeScriptConfiguration &
PackageJson.YarnConfiguration &
PackageJson.JSPMConfiguration;

/** Mark some properties as optional, leaving others unchanged */
export declare type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

/** Like Partial but recursive */
export declare type PartialDeep<T> = T extends Builtin
? T
: T extends Map<infer K, infer V>
? Map<PartialDeep<K>, PartialDeep<V>>
: T extends ReadonlyMap<infer K, infer V>
? ReadonlyMap<PartialDeep<K>, PartialDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<PartialDeep<K>, PartialDeep<V>>
: T extends Set<infer U>
? Set<PartialDeep<U>>
: T extends ReadonlySet<infer U>
? ReadonlySet<PartialDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<PartialDeep<U>>
: T extends Array<infer U>
? T extends IsTuple<T>
? {
    [K in keyof T]?: PartialDeep<T[K]>;
}
: Array<PartialDeep<U>>
: T extends Promise<infer U>
? Promise<PartialDeep<U>>
: T extends {}
? {
    [K in keyof T]?: PartialDeep<T[K]>;
}
: Partial<T>;

/**
 Converts a string literal to pascal-case.

 @example
 ```
 import {PascalCase} from 'type-fest';

 // Simple

 const someVariable: PascalCase<'foo-bar'> = 'FooBar';

 // Advanced

 type PascalCaseProps<T> = {
 	[K in keyof T as PascalCase<K>]: T[K]
 };

 interface RawOptions {
 	'dry-run': boolean;
 	'full_family_name': string;
 	foo: number;
 }

 const dbResult: CamelCasedProperties<ModelProps> = {
 	DryRun: true,
 	FullFamilyName: 'bar.js',
 	Foo: 123
 };
 ```

 @category Template Literals
 */
export declare type PascalCase<Value> = CamelCase<Value> extends string
	? Capitalize<CamelCase<Value>>
	: CamelCase<Value>;

/**
 * 获取对象的路径。最多支持 7 级路径。
 *
 * @deprecated 使用 `DotPath` 代替
 */
export declare type Path<T = any, L = any> = string | string[];

/**
 * 获取对象的路径值。最多支持 7 级路径。
 *
 * @deprecated 使用 `DotPathValue` 代替
 */
export declare type PathValue<T = any, L = any> = any;

/** Pick all properties of given type in object type */
export declare type PickBy<T, P> = Pick<
T,
    {
    [K in keyof T]: T[K] extends P ? K : never;
}[keyof T]
>;

/**
 Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

 @category Basic
 */
declare type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

/** Essentials */
declare type Primitive_2 = string | number | boolean | bigint | symbol | undefined | null;

/**
 Returns the type that is wrapped inside a `Promise` type.
 If the type is a nested Promise, it is unwrapped recursively until a non-Promise type is obtained.
 If the type is not a `Promise`, the type itself is returned.

 @example
 ```
 import {PromiseValue} from 'type-fest';

 type AsyncData = Promise<string>;
 let asyncData: PromiseValue<AsyncData> = Promise.resolve('ABC');

 type Data = PromiseValue<AsyncData>;
 let data: Data = await asyncData;

 // Here's an example that shows how this type reacts to non-Promise types.
 type SyncData = PromiseValue<string>;
 let syncData: SyncData = getSyncData();

 // Here's an example that shows how this type reacts to recursive Promise types.
 type RecursiveAsyncData = Promise<Promise<string> >;
 let recursiveAsyncData: PromiseValue<RecursiveAsyncData> = Promise.resolve(Promise.resolve('ABC'));
 ```

 @category Utilities
 */
declare type PromiseValue<PromiseType, Otherwise = PromiseType> = PromiseType extends Promise<infer Value>
	? {0: PromiseValue<Value>; 1: Value}[PromiseType extends Promise<unknown> ? 0 : 1]
	: Otherwise;

/** Like Readonly but recursive */
export declare type ReadonlyDeep<T> = T extends Builtin
? T
: T extends Map<infer K, infer V>
? ReadonlyMap<ReadonlyDeep<K>, ReadonlyDeep<V>>
: T extends ReadonlyMap<infer K, infer V>
? ReadonlyMap<ReadonlyDeep<K>, ReadonlyDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<ReadonlyDeep<K>, ReadonlyDeep<V>>
: T extends Set<infer U>
? ReadonlySet<ReadonlyDeep<U>>
: T extends ReadonlySet<infer U>
? ReadonlySet<ReadonlyDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<ReadonlyDeep<U>>
: T extends Promise<infer U>
? Promise<ReadonlyDeep<U>>
: T extends {}
? {
    readonly [K in keyof T]: ReadonlyDeep<T[K]>;
}
: Readonly<T>;

/** Gets keys of an object which are readonly */
export declare type ReadonlyKeys<T extends object> = {
    [P in keyof T]-?: IsFullyWritable<Pick<T, P>> extends true ? never : P;
}[keyof T];

/** Mark some properties as required, leaving others unchanged */
export declare type RequiredBy<T, RK extends keyof T> = Exclude<T, RK> & Required<Pick<T, RK>>;

/** Like Required but recursive */
export declare type RequiredDeep<T> = T extends Builtin
? NonNullable<T>
: T extends Map<infer K, infer V>
? Map<RequiredDeep<K>, RequiredDeep<V>>
: T extends ReadonlyMap<infer K, infer V>
? ReadonlyMap<RequiredDeep<K>, RequiredDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<RequiredDeep<K>, RequiredDeep<V>>
: T extends Set<infer U>
? Set<RequiredDeep<U>>
: T extends ReadonlySet<infer U>
? ReadonlySet<RequiredDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<RequiredDeep<U>>
: T extends Promise<infer U>
? Promise<RequiredDeep<U>>
: T extends {}
? {
    [K in keyof T]-?: RequiredDeep<T[K]>;
}
: NonNullable<T>;

/** Gets keys of an object which are required */
export declare type RequiredKeys<T> = Exclude<keyof T, OptionalKeys<T>>;

/**
 Create a function type with a return type of your choice and the same parameters as the given function type.

 Use-case: You want to define a wrapped function that returns something different while receiving the same parameters. For example, you might want to wrap a function that can throw an error into one that will return `undefined` instead.

 @example
 ```
 import {SetReturnType} from 'type-fest';

 type MyFunctionThatCanThrow = (foo: SomeType, bar: unknown) => SomeOtherType;

 type MyWrappedFunction = SetReturnType<MyFunctionThatCanThrow, SomeOtherType | undefined>;
 //=> type MyWrappedFunction = (foo: SomeType, bar: unknown) => SomeOtherType | undefined;
 ```

 @category Utilities
 */
declare type SetReturnType<Fn extends (...args: any[]) => any, TypeToReturn> =
	// Just using `Parameters<Fn>` isn't ideal because it doesn't handle the `this` fake parameter.
	Fn extends (this: infer ThisArg, ...args: infer Arguments) => any ? (
		// If a function did not specify the `this` fake parameter, it will be inferred to `unknown`.
		// We want to detect this situation just to display a friendlier type upon hovering on an IntelliSense-powered IDE.
		IsUnknown<ThisArg> extends true ? (...args: Arguments) => TypeToReturn : (this: ThisArg, ...args: Arguments) => TypeToReturn
	) : (
		// This part should be unreachable, but we make it meaningful just in case…
		(...args: Parameters<Fn>) => TypeToReturn
	);

/**
 Convert a string literal to snake-case.

 This can be useful when, for example, converting a camel-cased object property to a snake-cased SQL column name.

 @example
 ```
 import {SnakeCase} from 'type-fest';

 // Simple

 const someVariable: SnakeCase<'fooBar'> = 'foo_bar';

 // Advanced

 type SnakeCasedProperties<T> = {
 	[K in keyof T as SnakeCase<K>]: T[K]
 };

 interface ModelProps {
 	isHappy: boolean;
 	fullFamilyName: string;
 	foo: number;
 }

 const dbResult: SnakeCasedProperties<ModelProps> = {
 	'is_happy': true,
 	'full_family_name': 'Carla Smith',
 	foo: 123
 };
 ```

 @category Template Literals
 */
export declare type SnakeCase<Value> = DelimiterCase<Value, '_'>;

/**
 Represents an array of strings split using a given character or character set.

 Use-case: Defining the return type of a method like `String.prototype.split`.

 @example
 ```
 import {Split} from 'type-fest';

 declare function split<S extends string, D extends string>(string: S, separator: D): Split<S, D>;

 type Item = 'foo' | 'bar' | 'baz' | 'waldo';
 const items = 'foo,bar,baz,waldo';
 let array: Item[];

 array = split(items, ',');
 ```

 @category Template Literals
 */
declare type Split<
	S extends string,
	Delimiter extends string,
> = S extends `${infer Head}${Delimiter}${infer Tail}`
	? [Head, ...Split<Tail, Delimiter>]
	: S extends Delimiter
	? []
	: [S];

/**
 Unlike a simpler split, this one includes the delimiter splitted on in the resulting array literal. This is to enable splitting on, for example, upper-case characters.

 @category Template Literals
 */
declare type SplitIncludingDelimiters<Source extends string, Delimiter extends string> =
	Source extends '' ? [] :
	Source extends `${infer FirstPart}${Delimiter}${infer SecondPart}` ?
	(
		Source extends `${FirstPart}${infer UsedDelimiter}${SecondPart}`
			? UsedDelimiter extends Delimiter
				? Source extends `${infer FirstPart}${UsedDelimiter}${infer SecondPart}`
					? [...SplitIncludingDelimiters<FirstPart, Delimiter>, UsedDelimiter, ...SplitIncludingDelimiters<SecondPart, Delimiter>]
					: never
				: never
			: never
	) :
	[Source];

/**
 Takes the result of a splitted string literal and recursively concatenates it together into the desired casing.

 It receives `UsedWordSeparators` and `UsedUpperCaseCharacters` as input to ensure it's fully encapsulated.

 @see SplitIncludingDelimiters
 */
declare type StringArrayToDelimiterCase<Parts extends any[], UsedWordSeparators extends string, UsedUpperCaseCharacters extends string, Delimiter extends string> =
	Parts extends [`${infer FirstPart}`, ...infer RemainingParts]
		? `${StringPartToDelimiterCase<FirstPart, UsedWordSeparators, UsedUpperCaseCharacters, Delimiter>}${StringArrayToDelimiterCase<RemainingParts, UsedWordSeparators, UsedUpperCaseCharacters, Delimiter>}`
		: '';

/**
 Format a specific part of the splitted string literal that `StringArrayToDelimiterCase<>` fuses together, ensuring desired casing.

 @see StringArrayToDelimiterCase
 */
declare type StringPartToDelimiterCase<StringPart extends string, UsedWordSeparators extends string, UsedUpperCaseCharacters extends string, Delimiter extends string> =
	StringPart extends UsedWordSeparators ? Delimiter :
	StringPart extends UsedUpperCaseCharacters ? `${Delimiter}${Lowercase<StringPart>}` :
	StringPart;

declare type SubKeys<T, K extends string> = K extends keyof T ? `${K}.${DotPath<T[K]>}` : never;

export declare type Tail<T extends AnyArray_2> = T["length"] extends 0
? never
: ((...t: T) => void) extends (first: any, ...rest: infer Rest) => void
? Rest
: never;

export declare namespace TsConfigJson {
    	export namespace CompilerOptions {
        		export type JSX =
        			| 'preserve'
        			| 'react'
        			| 'react-jsx'
        			| 'react-jsxdev'
        			| 'react-native';

        		export type Module =
        			| 'CommonJS'
        			| 'AMD'
        			| 'System'
        			| 'UMD'
        			| 'ES6'
        			| 'ES2015'
        			| 'ES2020'
        			| 'ESNext'
        			| 'None'
        			// Lowercase alternatives
        			| 'commonjs'
        			| 'amd'
        			| 'system'
        			| 'umd'
        			| 'es6'
        			| 'es2015'
        			| 'es2020'
        			| 'esnext'
        			| 'none';

        		export type NewLine =
        			| 'CRLF'
        			| 'LF'
        			// Lowercase alternatives
        			| 'crlf'
        			| 'lf';

        		export type Target =
        			| 'ES3'
        			| 'ES5'
        			| 'ES6'
        			| 'ES2015'
        			| 'ES2016'
        			| 'ES2017'
        			| 'ES2018'
        			| 'ES2019'
        			| 'ES2020'
        			| 'ES2021'
        			| 'ESNext'
        			// Lowercase alternatives
        			| 'es3'
        			| 'es5'
        			| 'es6'
        			| 'es2015'
        			| 'es2016'
        			| 'es2017'
        			| 'es2018'
        			| 'es2019'
        			| 'es2020'
        			| 'es2021'
        			| 'esnext';

        		export type Lib =
        			| 'ES5'
        			| 'ES6'
        			| 'ES7'
        			| 'ES2015'
        			| 'ES2015.Collection'
        			| 'ES2015.Core'
        			| 'ES2015.Generator'
        			| 'ES2015.Iterable'
        			| 'ES2015.Promise'
        			| 'ES2015.Proxy'
        			| 'ES2015.Reflect'
        			| 'ES2015.Symbol.WellKnown'
        			| 'ES2015.Symbol'
        			| 'ES2016'
        			| 'ES2016.Array.Include'
        			| 'ES2017'
        			| 'ES2017.Intl'
        			| 'ES2017.Object'
        			| 'ES2017.SharedMemory'
        			| 'ES2017.String'
        			| 'ES2017.TypedArrays'
        			| 'ES2018'
        			| 'ES2018.AsyncGenerator'
        			| 'ES2018.AsyncIterable'
        			| 'ES2018.Intl'
        			| 'ES2018.Promise'
        			| 'ES2018.Regexp'
        			| 'ES2019'
        			| 'ES2019.Array'
        			| 'ES2019.Object'
        			| 'ES2019.String'
        			| 'ES2019.Symbol'
        			| 'ES2020'
        			| 'ES2020.BigInt'
        			| 'ES2020.Promise'
        			| 'ES2020.String'
        			| 'ES2020.Symbol.WellKnown'
        			| 'ES2020.SharedMemory'
        			| 'ES2020.Intl'
        			| 'ES2021'
        			| 'ES2021.Promise'
        			| 'ES2021.String'
        			| 'ES2021.WeakRef'
        			| 'ESNext'
        			| 'ESNext.Array'
        			| 'ESNext.AsyncIterable'
        			| 'ESNext.BigInt'
        			| 'ESNext.Intl'
        			| 'ESNext.Promise'
        			| 'ESNext.String'
        			| 'ESNext.Symbol'
        			| 'ESNext.WeakRef'
        			| 'DOM'
        			| 'DOM.Iterable'
        			| 'ScriptHost'
        			| 'WebWorker'
        			| 'WebWorker.ImportScripts'
        			| 'WebWorker.Iterable'
        			// Lowercase alternatives
        			| 'es5'
        			| 'es6'
        			| 'es7'
        			| 'es2015'
        			| 'es2015.collection'
        			| 'es2015.core'
        			| 'es2015.generator'
        			| 'es2015.iterable'
        			| 'es2015.promise'
        			| 'es2015.proxy'
        			| 'es2015.reflect'
        			| 'es2015.symbol.wellknown'
        			| 'es2015.symbol'
        			| 'es2016'
        			| 'es2016.array.include'
        			| 'es2017'
        			| 'es2017.intl'
        			| 'es2017.object'
        			| 'es2017.sharedmemory'
        			| 'es2017.string'
        			| 'es2017.typedarrays'
        			| 'es2018'
        			| 'es2018.asyncgenerator'
        			| 'es2018.asynciterable'
        			| 'es2018.intl'
        			| 'es2018.promise'
        			| 'es2018.regexp'
        			| 'es2019'
        			| 'es2019.array'
        			| 'es2019.object'
        			| 'es2019.string'
        			| 'es2019.symbol'
        			| 'es2020'
        			| 'es2020.bigint'
        			| 'es2020.promise'
        			| 'es2020.string'
        			| 'es2020.symbol.wellknown'
        			| 'es2020.sharedmemory'
        			| 'es2020.intl'
        			| 'es2021'
        			| 'es2021.promise'
        			| 'es2021.string'
        			| 'es2021.weakref'
        			| 'esnext'
        			| 'esnext.array'
        			| 'esnext.asynciterable'
        			| 'esnext.bigint'
        			| 'esnext.intl'
        			| 'esnext.promise'
        			| 'esnext.string'
        			| 'esnext.symbol'
        			| 'esnext.weakref'
        			| 'dom'
        			| 'dom.iterable'
        			| 'scripthost'
        			| 'webworker'
        			| 'webworker.importscripts'
        			| 'webworker.iterable';

        		export interface Plugin {
            			[key: string]: unknown;
            			/**
             			Plugin name.
             			*/
            			name?: string;
            		}

        		export type ImportsNotUsedAsValues =
        			| 'remove'
        			| 'preserve'
        			| 'error';

        		export type FallbackPolling =
        			| 'fixedPollingInterval'
        			| 'priorityPollingInterval'
        			| 'dynamicPriorityPolling'
        			| 'fixedInterval'
        			| 'priorityInterval'
        			| 'dynamicPriority'
        			| 'fixedChunkSize';

        		export type WatchDirectory =
        			| 'useFsEvents'
        			| 'fixedPollingInterval'
        			| 'dynamicPriorityPolling'
        			| 'fixedChunkSizePolling';

        		export type WatchFile =
        			| 'fixedPollingInterval'
        			| 'priorityPollingInterval'
        			| 'dynamicPriorityPolling'
        			| 'useFsEvents'
        			| 'useFsEventsOnParentDirectory'
        			| 'fixedChunkSizePolling';

        	}

    	export interface CompilerOptions {
        		/**
         		The character set of the input files.

         		@default 'utf8'
         		*/
        		charset?: string;

        		/**
         		Enables building for project references.

         		@default true
         		*/
        		composite?: boolean;

        		/**
         		Generates corresponding d.ts files.

         		@default false
         		*/
        		declaration?: boolean;

        		/**
         		Specify output directory for generated declaration files.

         		Requires TypeScript version 2.0 or later.
         		*/
        		declarationDir?: string;

        		/**
         		Show diagnostic information.

         		@default false
         		*/
        		diagnostics?: boolean;

        		/**
         		Reduce the number of projects loaded automatically by TypeScript.

         		Requires TypeScript version 4.0 or later.

         		@default false
         		*/
        		disableReferencedProjectLoad?: boolean;

        		/**
         		Enforces using indexed accessors for keys declared using an indexed type.

         		Requires TypeScript version 4.2 or later.

         		@default false
         		*/
        		noPropertyAccessFromIndexSignature?: boolean;

        		/**
         		Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.

         		@default false
         		*/
        		emitBOM?: boolean;

        		/**
         		Only emit `.d.ts` declaration files.

         		@default false
         		*/
        		emitDeclarationOnly?: boolean;

        		/**
         		Differentiate between undefined and not present when type checking.

         		Requires TypeScript version 4.4 or later.

         		@default false
         		*/
        		exactOptionalPropertyTypes?: boolean;

        		/**
         		Enable incremental compilation.

         		@default `composite`
         		*/
        		incremental?: boolean;

        		/**
         		Specify file to store incremental compilation information.

         		@default '.tsbuildinfo'
         		*/
        		tsBuildInfoFile?: string;

        		/**
         		Emit a single file with source maps instead of having a separate file.

         		@default false
         		*/
        		inlineSourceMap?: boolean;

        		/**
         		Emit the source alongside the sourcemaps within a single file.

         		Requires `--inlineSourceMap` to be set.

         		@default false
         		*/
        		inlineSources?: boolean;

        		/**
         		Specify what JSX code is generated.

         		@default 'preserve'
         		*/
        		jsx?: CompilerOptions.JSX;

        		/**
         		Specifies the object invoked for `createElement` and `__spread` when targeting `'react'` JSX emit.

         		@default 'React'
         		*/
        		reactNamespace?: string;

        		/**
         		Specify the JSX factory function to use when targeting React JSX emit, e.g. `React.createElement` or `h`.

         		Requires TypeScript version 2.1 or later.

         		@default 'React.createElement'
         		*/
        		jsxFactory?: string;

        		/**
         		Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'.

         		Requires TypeScript version 4.0 or later.

         		@default 'React.Fragment'
         		*/
        		jsxFragmentFactory?: string;

        		/**
         		Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.

         		Requires TypeScript version 4.1 or later.

         		@default 'react'
         		*/
        		jsxImportSource?: string;

        		/**
         		Print names of files part of the compilation.

         		@default false
         		*/
        		listFiles?: boolean;

        		/**
         		Specifies the location where debugger should locate map files instead of generated locations.
         		*/
        		mapRoot?: string;

        		/**
         		Specify module code generation: 'None', 'CommonJS', 'AMD', 'System', 'UMD', 'ES6', 'ES2015' or 'ESNext'. Only 'AMD' and 'System' can be used in conjunction with `--outFile`. 'ES6' and 'ES2015' values may be used when targeting 'ES5' or lower.

         		@default ['ES3', 'ES5'].includes(target) ? 'CommonJS' : 'ES6'
         		*/
        		module?: CompilerOptions.Module;

        		/**
         		Specifies module resolution strategy: 'node' (Node) or 'classic' (TypeScript pre 1.6).

         		@default ['AMD', 'System', 'ES6'].includes(module) ? 'classic' : 'node'
         		*/
        		moduleResolution?: 'classic' | 'node';

        		/**
         		Specifies the end of line sequence to be used when emitting files: 'crlf' (Windows) or 'lf' (Unix).

         		Default: Platform specific
         		*/
        		newLine?: CompilerOptions.NewLine;

        		/**
         		Do not emit output.

         		@default false
         		*/
        		noEmit?: boolean;

        		/**
         		Do not generate custom helper functions like `__extends` in compiled output.

         		@default false
         		*/
        		noEmitHelpers?: boolean;

        		/**
         		Do not emit outputs if any type checking errors were reported.

         		@default false
         		*/
        		noEmitOnError?: boolean;

        		/**
         		Warn on expressions and declarations with an implied 'any' type.

         		@default false
         		*/
        		noImplicitAny?: boolean;

        		/**
         		Raise error on 'this' expressions with an implied any type.

         		@default false
         		*/
        		noImplicitThis?: boolean;

        		/**
         		Report errors on unused locals.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		noUnusedLocals?: boolean;

        		/**
         		Report errors on unused parameters.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		noUnusedParameters?: boolean;

        		/**
         		Do not include the default library file (lib.d.ts).

         		@default false
         		*/
        		noLib?: boolean;

        		/**
         		Do not add triple-slash references or module import targets to the list of compiled files.

         		@default false
         		*/
        		noResolve?: boolean;

        		/**
         		Disable strict checking of generic signatures in function types.

         		@default false
         		*/
        		noStrictGenericChecks?: boolean;

        		/**
         		@deprecated use `skipLibCheck` instead.
         		*/
        		skipDefaultLibCheck?: boolean;

        		/**
         		Skip type checking of declaration files.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		skipLibCheck?: boolean;

        		/**
         		Concatenate and emit output to single file.
         		*/
        		outFile?: string;

        		/**
         		Redirect output structure to the directory.
         		*/
        		outDir?: string;

        		/**
         		Do not erase const enum declarations in generated code.

         		@default false
         		*/
        		preserveConstEnums?: boolean;

        		/**
         		Do not resolve symlinks to their real path; treat a symlinked file like a real one.

         		@default false
         		*/
        		preserveSymlinks?: boolean;

        		/**
         		Keep outdated console output in watch mode instead of clearing the screen.

         		@default false
         		*/
        		preserveWatchOutput?: boolean;

        		/**
         		Stylize errors and messages using color and context (experimental).

         		@default true // Unless piping to another program or redirecting output to a file.
         		*/
        		pretty?: boolean;

        		/**
         		Do not emit comments to output.

         		@default false
         		*/
        		removeComments?: boolean;

        		/**
         		Specifies the root directory of input files.

         		Use to control the output directory structure with `--outDir`.
         		*/
        		rootDir?: string;

        		/**
         		Unconditionally emit imports for unresolved files.

         		@default false
         		*/
        		isolatedModules?: boolean;

        		/**
         		Generates corresponding '.map' file.

         		@default false
         		*/
        		sourceMap?: boolean;

        		/**
         		Specifies the location where debugger should locate TypeScript files instead of source locations.
         		*/
        		sourceRoot?: string;

        		/**
         		Suppress excess property checks for object literals.

         		@default false
         		*/
        		suppressExcessPropertyErrors?: boolean;

        		/**
         		Suppress noImplicitAny errors for indexing objects lacking index signatures.

         		@default false
         		*/
        		suppressImplicitAnyIndexErrors?: boolean;

        		/**
         		Do not emit declarations for code that has an `@internal` annotation.
         		*/
        		stripInternal?: boolean;

        		/**
         		Specify ECMAScript target version.

         		@default 'es3'
         		*/
        		target?: CompilerOptions.Target;

        		/**
         		Default catch clause variables as `unknown` instead of `any`.

         		Requires TypeScript version 4.4 or later.

         		@default false
         		*/
        		useUnknownInCatchVariables?: boolean;

        		/**
         		Watch input files.

         		@default false
         		*/
        		watch?: boolean;

        		/**
         		Specify the polling strategy to use when the system runs out of or doesn't support native file watchers.

         		Requires TypeScript version 3.8 or later.
         		*/
        		fallbackPolling?: CompilerOptions.FallbackPolling;

        		/**
         		Specify the strategy for watching directories under systems that lack recursive file-watching functionality.

         		Requires TypeScript version 3.8 or later.

         		@default 'useFsEvents'
         		*/
        		watchDirectory?: CompilerOptions.WatchDirectory;

        		/**
         		Specify the strategy for watching individual files.

         		Requires TypeScript version 3.8 or later.

         		@default 'useFsEvents'
         		*/
        		watchFile?: CompilerOptions.WatchFile;

        		/**
         		Enables experimental support for ES7 decorators.

         		@default false
         		*/
        		experimentalDecorators?: boolean;

        		/**
         		Emit design-type metadata for decorated declarations in source.

         		@default false
         		*/
        		emitDecoratorMetadata?: boolean;

        		/**
         		Do not report errors on unused labels.

         		@default false
         		*/
        		allowUnusedLabels?: boolean;

        		/**
         		Report error when not all code paths in function return a value.

         		@default false
         		*/
        		noImplicitReturns?: boolean;

        		/**
         		Add `undefined` to a type when accessed using an index.

         		Requires TypeScript version 4.1 or later.

         		@default false
         		*/
        		noUncheckedIndexedAccess?: boolean;

        		/**
         		Report errors for fallthrough cases in switch statement.

         		@default false
         		*/
        		noFallthroughCasesInSwitch?: boolean;

        		/**
         		Ensure overriding members in derived classes are marked with an override modifier.

         		@default false
         		*/
        		noImplicitOverride?: boolean;

        		/**
         		Do not report errors on unreachable code.

         		@default false
         		*/
        		allowUnreachableCode?: boolean;

        		/**
         		Disallow inconsistently-cased references to the same file.

         		@default false
         		*/
        		forceConsistentCasingInFileNames?: boolean;

        		/**
         		Emit a v8 CPU profile of the compiler run for debugging.

         		Requires TypeScript version 3.7 or later.

         		@default 'profile.cpuprofile'
         		*/
        		generateCpuProfile?: string;

        		/**
         		Base directory to resolve non-relative module names.
         		*/
        		baseUrl?: string;

        		/**
         		Specify path mapping to be computed relative to baseUrl option.
         		*/
        		paths?: Record<string, string[]>;

        		/**
         		List of TypeScript language server plugins to load.

         		Requires TypeScript version 2.3 or later.
         		*/
        		plugins?: CompilerOptions.Plugin[];

        		/**
         		Specify list of root directories to be used when resolving modules.
         		*/
        		rootDirs?: string[];

        		/**
         		Specify list of directories for type definition files to be included.

         		Requires TypeScript version 2.0 or later.
         		*/
        		typeRoots?: string[];

        		/**
         		Type declaration files to be included in compilation.

         		Requires TypeScript version 2.0 or later.
         		*/
        		types?: string[];

        		/**
         		Enable tracing of the name resolution process.

         		@default false
         		*/
        		traceResolution?: boolean;

        		/**
         		Allow javascript files to be compiled.

         		@default false
         		*/
        		allowJs?: boolean;

        		/**
         		Do not truncate error messages.

         		@default false
         		*/
        		noErrorTruncation?: boolean;

        		/**
         		Allow default imports from modules with no default export. This does not affect code emit, just typechecking.

         		@default module === 'system' || esModuleInterop
         		*/
        		allowSyntheticDefaultImports?: boolean;

        		/**
         		Do not emit `'use strict'` directives in module output.

         		@default false
         		*/
        		noImplicitUseStrict?: boolean;

        		/**
         		Enable to list all emitted files.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		listEmittedFiles?: boolean;

        		/**
         		Disable size limit for JavaScript project.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		disableSizeLimit?: boolean;

        		/**
         		List of library files to be included in the compilation.

         		Requires TypeScript version 2.0 or later.
         		*/
        		lib?: CompilerOptions.Lib[];

        		/**
         		Enable strict null checks.

         		Requires TypeScript version 2.0 or later.

         		@default false
         		*/
        		strictNullChecks?: boolean;

        		/**
         		The maximum dependency depth to search under `node_modules` and load JavaScript files. Only applicable with `--allowJs`.

         		@default 0
         		*/
        		maxNodeModuleJsDepth?: number;

        		/**
         		Import emit helpers (e.g. `__extends`, `__rest`, etc..) from tslib.

         		Requires TypeScript version 2.1 or later.

         		@default false
         		*/
        		importHelpers?: boolean;

        		/**
         		Specify emit/checking behavior for imports that are only used for types.

         		@default 'remove'
         		*/
        		importsNotUsedAsValues?: CompilerOptions.ImportsNotUsedAsValues;

        		/**
         		Parse in strict mode and emit `'use strict'` for each source file.

         		Requires TypeScript version 2.1 or later.

         		@default false
         		*/
        		alwaysStrict?: boolean;

        		/**
         		Enable all strict type checking options.

         		Requires TypeScript version 2.3 or later.

         		@default false
         		*/
        		strict?: boolean;

        		/**
         		Enable stricter checking of of the `bind`, `call`, and `apply` methods on functions.

         		@default false
         		*/
        		strictBindCallApply?: boolean;

        		/**
         		Provide full support for iterables in `for-of`, spread, and destructuring when targeting `ES5` or `ES3`.

         		Requires TypeScript version 2.3 or later.

         		@default false
         		*/
        		downlevelIteration?: boolean;

        		/**
         		Report errors in `.js` files.

         		Requires TypeScript version 2.3 or later.

         		@default false
         		*/
        		checkJs?: boolean;

        		/**
         		Disable bivariant parameter checking for function types.

         		Requires TypeScript version 2.6 or later.

         		@default false
         		*/
        		strictFunctionTypes?: boolean;

        		/**
         		Ensure non-undefined class properties are initialized in the constructor.

         		Requires TypeScript version 2.7 or later.

         		@default false
         		*/
        		strictPropertyInitialization?: boolean;

        		/**
         		Emit `__importStar` and `__importDefault` helpers for runtime Babel ecosystem compatibility and enable `--allowSyntheticDefaultImports` for typesystem compatibility.

         		Requires TypeScript version 2.7 or later.

         		@default false
         		*/
        		esModuleInterop?: boolean;

        		/**
         		Allow accessing UMD globals from modules.

         		@default false
         		*/
        		allowUmdGlobalAccess?: boolean;

        		/**
         		Resolve `keyof` to string valued property names only (no numbers or symbols).

         		Requires TypeScript version 2.9 or later.

         		@default false
         		*/
        		keyofStringsOnly?: boolean;

        		/**
         		Emit ECMAScript standard class fields.

         		Requires TypeScript version 3.7 or later.

         		@default false
         		*/
        		useDefineForClassFields?: boolean;

        		/**
         		Generates a sourcemap for each corresponding `.d.ts` file.

         		Requires TypeScript version 2.9 or later.

         		@default false
         		*/
        		declarationMap?: boolean;

        		/**
         		Include modules imported with `.json` extension.

         		Requires TypeScript version 2.9 or later.

         		@default false
         		*/
        		resolveJsonModule?: boolean;

        		/**
         		Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it.

         		Requires TypeScript version 3.8 or later.

         		@default false
         		*/
        		assumeChangesOnlyAffectDirectDependencies?: boolean;

        		/**
         		Output more detailed compiler performance information after building.

         		@default false
         		*/
        		extendedDiagnostics?: boolean;

        		/**
         		Print names of files that are part of the compilation and then stop processing.

         		@default false
         		*/
        		listFilesOnly?: boolean;

        		/**
         		Disable preferring source files instead of declaration files when referencing composite projects.

         		@default true if composite, false otherwise
         		*/
        		disableSourceOfProjectReferenceRedirect?: boolean;

        		/**
         		Opt a project out of multi-project reference checking when editing.

         		Requires TypeScript version 3.8 or later.

         		@default false
         		*/
        		disableSolutionSearching?: boolean;

        		/**
         		Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.

         		Requires TypeScript version 4.2 or later.

         		@default false
         		*/
        		explainFiles?: boolean;
        	}

    	/**
     	Auto type (.d.ts) acquisition options for this project.

     	Requires TypeScript version 2.1 or later.
     	*/
    	export interface TypeAcquisition {
        		/**
         		Enable auto type acquisition.
         		*/
        		enable?: boolean;

        		/**
         		Specifies a list of type declarations to be included in auto type acquisition. For example, `['jquery', 'lodash']`.
         		*/
        		include?: string[];

        		/**
         		Specifies a list of type declarations to be excluded from auto type acquisition. For example, `['jquery', 'lodash']`.
         		*/
        		exclude?: string[];
        	}

    	export interface References {
        		/**
         		A normalized path on disk.
         		*/
        		path: string;

        		/**
         		The path as the user originally wrote it.
         		*/
        		originalPath?: string;

        		/**
         		True if the output of this reference should be prepended to the output of this project.

         		Only valid for `--outFile` compilations.
         		*/
        		prepend?: boolean;

        		/**
         		True if it is intended that this reference form a circularity.
         		*/
        		circular?: boolean;
        	}
}

/**
 Type for [TypeScript's `tsconfig.json` file](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) (TypeScript 3.7).

 @category Miscellaneous
 */
export declare interface TsConfigJson {
    	/**
     	Instructs the TypeScript compiler how to compile `.ts` files.
     	*/
    	compilerOptions?: TsConfigJson.CompilerOptions;

    	/**
     	Auto type (.d.ts) acquisition options for this project.

     	Requires TypeScript version 2.1 or later.
     	*/
    	typeAcquisition?: TsConfigJson.TypeAcquisition;

    	/**
     	Enable Compile-on-Save for this project.
     	*/
    	compileOnSave?: boolean;

    	/**
     	Path to base configuration file to inherit from.

     	Requires TypeScript version 2.1 or later.
     	*/
    	extends?: string;

    	/**
     	If no `files` or `include` property is present in a `tsconfig.json`, the compiler defaults to including all files in the containing directory and subdirectories except those specified by `exclude`. When a `files` property is specified, only those files and those specified by `include` are included.
     	*/
    	files?: string[];

    	/**
     	Specifies a list of files to be excluded from compilation. The `exclude` property only affects the files included via the `include` property and not the `files` property.

     	Glob patterns require TypeScript version 2.0 or later.
     	*/
    	exclude?: string[];

    	/**
     	Specifies a list of glob patterns that match files to be included in compilation.

     	If no `files` or `include` property is present in a `tsconfig.json`, the compiler defaults to including all files in the containing directory and subdirectories except those specified by `exclude`.

     	Requires TypeScript version 2.0 or later.
     	*/
    	include?: string[];

    	/**
     	Referenced projects.

     	Requires TypeScript version 3.0 or later.
     	*/
    	references?: TsConfigJson.References[];
}

/**
 Convert a union type to an intersection type using [distributive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).

 Inspired by [this Stack Overflow answer](https://stackoverflow.com/a/50375286/2172153).

 @example
 ```
 import {UnionToIntersection} from 'type-fest';

 type Union = {the(): void} | {great(arg: string): void} | {escape: boolean};

 type Intersection = UnionToIntersection<Union>;
 //=> {the(): void; great(arg: string): void; escape: boolean};
 ```

 A more applicable example which could make its way into your library code follows.

 @example
 ```
 import {UnionToIntersection} from 'type-fest';

 class CommandOne {
 	commands: {
 		a1: () => undefined,
 		b1: () => undefined,
 	}
 }

 class CommandTwo {
 	commands: {
 		a2: (argA: string) => undefined,
 		b2: (argB: string) => undefined,
 	}
 }

 const union = [new CommandOne(), new CommandTwo()].map(instance => instance.commands);
 type Union = typeof union;
 //=> {a1(): void; b1(): void} | {a2(argA: string): void; b2(argB: string): void}

 type Intersection = UnionToIntersection<Union>;
 //=> {a1(): void; b1(): void; a2(argA: string): void; b2(argB: string): void}
 ```

 @category Utilities
 */
export declare type UnionToIntersection<Union> = (
	// `extends unknown` is always going to be the case and is used to convert the
	// `Union` into a [distributive conditional
	// type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).
	Union extends unknown
		// The union type is used as the only argument to a function since the union
		// of function arguments is an intersection.
		? (distributedUnion: Union) => void
		// This won't happen.
		: never
		// Infer the `Intersection` type since TypeScript represents the positional
		// arguments of unions of functions as an intersection of the union.
	) extends ((mergedIntersection: infer Intersection) => void)
		? Intersection
		: never;

declare type UpperCaseCharacters = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z';

/** Easily extract the type of a given object's values */
export declare type ValueOf<T> = T[keyof T];

declare type WordSeparators = '-' | '_' | ' ';

/** Make readonly object writable */
export declare type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};

/** Like Writable but recursive */
export declare type WritableDeep<T> = T extends Builtin
? T
: T extends Map<infer K, infer V>
? Map<WritableDeep<K>, WritableDeep<V>>
: T extends ReadonlyMap<infer K, infer V>
? Map<WritableDeep<K>, WritableDeep<V>>
: T extends WeakMap<infer K, infer V>
? WeakMap<WritableDeep<K>, WritableDeep<V>>
: T extends Set<infer U>
? Set<WritableDeep<U>>
: T extends ReadonlySet<infer U>
? Set<WritableDeep<U>>
: T extends WeakSet<infer U>
? WeakSet<WritableDeep<U>>
: T extends Promise<infer U>
? Promise<WritableDeep<U>>
: T extends {}
? {
    -readonly [K in keyof T]: WritableDeep<T[K]>;
}
: T;

/** Gets keys of an object which are writable */
export declare type WritableKeys<T extends {}> = {
    [P in keyof T]-?: IsFullyWritable<Pick<T, P>> extends true ? P : never;
}[keyof T];

export { }
