#!/usr/bin/env node
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.run = run;

var TSNode = _interopRequireWildcard(require("ts-node"));

var _consola = _interopRequireDefault(require("consola"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _ora = _interopRequireDefault(require("ora"));

var _path = _interopRequireDefault(require("path"));

var _prompts = _interopRequireDefault(require("prompts"));

var _yargs = _interopRequireDefault(require("yargs"));

var _vtils = require("vtils");

var _Generator = require("./Generator");

TSNode.register({
  // 不加载本地的 tsconfig.json
  skipProject: true,
  // 仅转译，不做类型检查
  transpileOnly: true,
  // 自定义编译选项
  compilerOptions: {
    strict: false,
    target: 'es2017',
    module: 'commonjs',
    moduleResolution: 'node',
    declaration: false,
    removeComments: false,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    importHelpers: false,
    // 转换 js，支持在 ytt.config.js 里使用最新语法
    allowJs: true,
    lib: ['es2017']
  }
});

async function run(cmd, options) {
  let useCustomConfigFile = false;
  let cwd;
  let configTSFile;
  let configJSFile;
  let configFile;
  let configFileExist;

  if (!(options != null && options.configFile)) {
    cwd = process.cwd();
    configTSFile = _path.default.join(cwd, 'ytt.config.ts');
    configJSFile = _path.default.join(cwd, 'ytt.config.js');
    const configTSFileExist = await _fsExtra.default.pathExists(configTSFile);
    const configJSFileExist = !configTSFileExist && (await _fsExtra.default.pathExists(configJSFile));
    configFileExist = configTSFileExist || configJSFileExist;
    configFile = configTSFileExist ? configTSFile : configJSFile;
  } else {
    useCustomConfigFile = true;
    configFile = options.configFile;
    cwd = _path.default.dirname(configFile);
    configFileExist = await _fsExtra.default.pathExists(configFile);
  }

  if (cmd === 'help') {
    console.log(`\n${(0, _vtils.dedent)`
        # 用法
          初始化配置文件: ytt init
          生成代码: ytt
          查看帮助: ytt help

        # GitHub
          https://github.com/fjc0k/yapi-to-typescript
      `}\n`);
  } else if (cmd === 'init') {
    if (configFileExist) {
      _consola.default.info(`检测到配置文件: ${configFile}`);

      const answers = await (0, _prompts.default)({
        message: '是否覆盖已有配置文件?',
        name: 'override',
        type: 'confirm'
      });
      if (!answers.override) return;
    }

    let outputConfigFile;
    let outputConfigFileType;

    if (useCustomConfigFile) {
      outputConfigFile = configFile;
      outputConfigFileType = configFile.endsWith('.js') ? 'js' : 'ts';
    } else {
      const answers = await (0, _prompts.default)({
        message: '选择配置文件类型?',
        name: 'configFileType',
        type: 'select',
        choices: [{
          title: 'TypeScript(ytt.config.ts)',
          value: 'ts'
        }, {
          title: 'JavaScript(ytt.config.js)',
          value: 'js'
        }]
      });
      outputConfigFile = answers.configFileType === 'js' ? configJSFile : configTSFile;
      outputConfigFileType = answers.configFileType;
    }

    await _fsExtra.default.outputFile(outputConfigFile, (0, _vtils.dedent)`
        import { defineConfig } from 'yapi-to-typescript'

        export default defineConfig([
          {
            serverUrl: 'http://foo.bar',
            typesOnly: false,
            target: '${outputConfigFileType === 'js' ? 'javascript' : 'typescript'}',
            reactHooks: {
              enabled: false,
            },
            prodEnvName: 'production',
            outputFilePath: 'src/api/index.${outputConfigFileType}',
            requestFunctionFilePath: 'src/api/request.${outputConfigFileType}',
            dataKey: 'data',
            projects: [
              {
                token: 'hello',
                categories: [
                  {
                    id: 0,
                    getRequestFunctionName(interfaceInfo, changeCase) {
                      return changeCase.camelCase(
                        interfaceInfo.parsedPath.name,
                      )
                    },
                  },
                ],
              },
            ],
          },
        ])
      `);

    _consola.default.success('写入配置文件完毕');
  } else {
    if (!configFileExist) {
      return _consola.default.error(`找不到配置文件: ${useCustomConfigFile ? configFile : `${configTSFile} 或 ${configJSFile}`}`);
    }

    _consola.default.success(`找到配置文件: ${configFile}`);

    let generator;
    let spinner;

    try {
      const config = require(configFile).default;

      generator = new _Generator.Generator(config, {
        cwd
      });
      spinner = (0, _ora.default)('正在获取数据并生成代码...').start();
      const delayNotice = (0, _vtils.wait)(5000);
      delayNotice.then(() => {
        spinner.text = `正在获取数据并生成代码... (若长时间处于此状态，请检查是否有接口定义的数据过大导致拉取或解析缓慢)`;
      });
      await generator.prepare();
      delayNotice.cancel();
      const output = await generator.generate();
      spinner.stop();

      _consola.default.success('获取数据并生成代码完毕');

      await generator.write(output);

      _consola.default.success('写入文件完毕');

      await generator.destroy();
    } catch (err) {
      var _spinner, _generator;

      (_spinner = spinner) == null ? void 0 : _spinner.stop();
      await ((_generator = generator) == null ? void 0 : _generator.destroy());
      /* istanbul ignore next */

      return _consola.default.error(err);
    }
  }
}
/* istanbul ignore next */


if (require.main === module) {
  const argv = (0, _yargs.default)(process.argv).alias('c', 'config').argv;
  run(argv._[2], {
    configFile: argv.config ? _path.default.resolve(process.cwd(), argv.config) : undefined
  });
}